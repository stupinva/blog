<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="перевод,perl" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2013-08-18 -->
		<title>Хеннинг Кох. Написание серьёзных приложений на Perl. Безусловный минимум, который вам необходимо знать, 2004</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Хеннинг Кох. Написание серьёзных приложений на Perl. Безусловный минимум, который вам необходимо знать, 2004</h1>

		<p>Перевод статьи: <a href="http://www.netalive.org/tinkering/serious-perl/">Writing serious Perl. The absolute minimum you need to know</a></p>

		<p>Автор: <a href="mailto:jaz@netalive.org">Хеннинг Кох</a></p>

		<p>Чрезвычайно гибкий синтаксис Perl'а позволяет легко писать код, который сложнее читать и поддерживать, чем этого хотелось бы. Эта статья описывает некоторые основополагающие практики, которые я считаю необходимыми для написания понятных и лаконичных программ на Perl.</p>

		<h2><a name="a">1. Пространства имён</a></h2>

		<p>Один пакет никогда не должен пересекаться с пространством имён другого пакета, до тех пор, пока тот явно не попросит об этом. Поэтому, никогда не определяйте методы в другом скрипте для использования с require. Всегда оборачивайте вашу библиотеку в пакет и используйте его. Таким образом пространство имён останется чистым и отделённым:</p>

		<pre class="code">package Sophie;
sub say_hello {
  print "Привет, Мир!";
}

package Clara;
use Sophie;          # Загрузить пакет, но НЕ импортировать какие-либо методы
say_hello();         # Не сработает
Sophie-&gt;say_hello(); # Правильное использование
Sophie::say_hello(); # Работает, кроме наследуемых методов</pre>

		<h3><a name="a1">1.1. Корень пространства имён</a></h3>

		<p>Если вы используете выгруженный пакет Some::Package, Perl ищет файл Some/Package.pm в текущем каталоге. Если этот файл не существует, поиск продолжается в другом корне пространства имён (например, в c:/perl/lib) из глобального массива @INC.</p>

		<p>Хорошая мысль сохранить пакеты вашего приложения в отдельный каталог, например в lib, и добавлять этот каталог к списку корней пространства имён с помощью use lib 'my/root/path':</p>

		<pre class="code">use lib 'lib';     # Добавить подкаталог 'lib' к корневому пространству имён @INC
use Some::Package; # Пройтись по @INC в поисках файла пакета</pre>

		<h3><a name="a2">1.2. Экспорт идентификаторов</a></h3>

		<p>Бывают случаи, когда нужно экспортировать методы или имен переменных в вызывающий пакет. Я делаю так лишь в редких случаях, когда очень-очень часто требуются статические вспомогательные методы. Для экспорта идентификаторов наследуйте от класса Exporter и заполните массив @EXPORT идентификаторов, которые хотите экспортировать:</p>

		<pre class="code">package Util;
use base 'Exporter';
our @EXPORT = ('foo', 'bar');

sub foo {
  print "foo!";
}
sub bar {
  print "bar!";
}

package Amy;
use Util; # Импортировать символы в @EXPORT
foo();    # Работает
bar();    # Работает</pre>

		<p>Постарайтесь не засорять пространство имён другого пакета, если у вас нет для этого достаточно уважительной причины! Однако, как бы то ни было, большинство пакетов на CPAN экспортируют идентификаторы при их явном подключении.</p>

		<p>Будет неплохо, если оставить программам возможность самим решать, какие идентификаторы нужно экспортировать в их пространство имён. Для этого можно воспользоваться массивом @EXPORT_OK или @EXPORT.</p>

		<pre class="code">package Util;
use base 'Exporter';
our @EXPORT_OK = ('foo', 'bar');

sub foo {
  print "foo!";
}
sub bar {
  print "bar!";
}

package Amy;
use Util 'foo'; # Импортировать только foo()
foo();          # Работает
bar();          # Не сработает</pre>

		<h2><a name="b">2. Быстрое приготовление структур данных</a></h2>

		<p>Используйте { } для создания ссылок на анонимные хэши. Используйте [ ] для создания ссылок на анонимные массивы. Сочетайте эти конструкции для создания более сложных структур данных вроде списков из хэшей:</p>

		<pre class="code">my @students = ( { name         =&gt; 'Clara',
                   registration =&gt; 10405,
                   grades       =&gt; [ 2, 3, 2 ] },
                 { name         =&gt; 'Amy',
                   registration =&gt; 47200,
                   grades       =&gt; [ 1, 3, 1 ] },
                 { name         =&gt; 'Deborah',
                   registration =&gt; 12022,
                   grades       =&gt; [ 4, 4, 4 ] } );</pre>

		<p>Используйте -&gt; для получения доступа к значениям структуры данных:</p>

		<pre class="code"># Напечатать имена всех студентов
foreach my $student (@students) {
  print $student-&gt;{name} . "\n";
}

# Напечатать вторую оценку Клары
print $students[0]-&gt;{grades}-&gt;[1];

# Удалить код регистрации Клары
delete $students[0]-&gt;{registration};</pre>

		<h2><a name="c">3. Классы и объекты</a></h2>

		<p>Пакеты - это классы. Объекты - это обычно ссылки на хэши, "благословлённые"<a name="btn1"><a href="#tn1"><sup>1</sup></a></a> именем класса. Атрибуты - это пары ключ/значение в хэше.</p>

		<h3><a name="c1">3.1. Конструкторы</a></h3>

		<p>Конструкторы - это статические методы, которым довелась участь возвращать объекты:</p>

		<pre class="code">package Student;

sub new {
  my($class, $name) = @_;       # Первый параметр - название класса
  my $self = { name =&gt; $name }; # Ссылка на анонимный хэш, содержащий атрибуты экземпляра
  bless($self, $class);         # Говорит: $self - это $class
  return $self;
}

package main;
use Student;
my $amy = Student-&gt;new('Amy');
print $amy-&gt;{name};             # Доступ к атрибуту</pre>

		<p>Вместо Student-&gt;new('Amy') можно также написать Student('Amy'). Однако отметим, что в этом случае Perl полагается на непредсказуемую эвристику, чтобы понять ваши истинные намерения и иногда может ошибаться.</p>

		<h3><a name="c2">3.2. Множественные конструкторы</a></h3>

		<p>Поскольку ключевое слово new не имеет особого значения в Perl, можно создавать столько методов-конструкторов, сколько захочется и называть их как захочется. Например, вам может потребоваться два разных конструктора, в зависимости от того, каким образом нужно сформировать объект - загрузив существующую запись из базы данных или создав новый экземпляр с нуля:</p>

		<pre class="code">my $amy = Student-&gt;existing('Amy');
my $clara = Student-&gt;create();</pre>

		<p>Поскольку конструктор явным образом возвращает конструируемый объект, $self не является чем-то необычным. Например, вы можете взять $self из статического кэша уже сконструированных объектов:</p>

		<pre class="code">package Coke;
my %CACHE;

sub new {
  my($class, $type) = @_;
  return $CACHE{$type} if $CACHE{$type}; # По возможности использовать копию из кэша
  my $self = $class-&gt;from_db($type);     # Получить его из базы данных
  $CACHE{$type} = $self;                 # Помещаем в кэш полученный объект
  return $self;
}

sub from_db {
  my($class, $type) = @_;
  my $self = ...        # Получить данные из базы данных
  bless($self, $class); # Сделать $self экземпляром $class
  return $self;
}

package main;
use Coke;

my $foo = Coke-&gt;new('Lemon');   # Получение из базы данных
my $bar = Coke-&gt;new('Vanilla'); # Получение из базы данных
my $baz = Coke-&gt;new('Lemon');   # Используется копия из кэша</pre>

		<p>Ради полноты картины я должен напомнить, что ссылки в %CACHE будут удерживать кэшированные объекты в памяти, даже если остальные экземпляры объектов перестали существовать. Поэтому, если ваши кэшированные объекты обладают методами-деструкторами, они не будут вызваны до момента завершения программы.</p>

		<h3><a name="c3">3.3. Методы экземпляров</a></h3>

		<p>Методы экземпляров получают ссылку на вызываемый объект в первом параметре:</p>

		<pre class="code">package Student;

sub work {
  my($self) = @_;
  print "$self работает\n";
}
sub sleep {
  my($self) = @_;
  print "$self спит\n";
}

package main;
use Student;

my $amy = Student-&gt;new('Amy');
$amy-&gt;work();
$amy-&gt;sleep();</pre>

		<p>Ссылка на себя (this в Java) никогда не подразумевается в Perl:</p>

		<pre class="code">sub work {
  my($self) = @_;
  sleep();        # Не делайте этого!
  $self-&gt;sleep(); # Правильное использование
}</pre>

		<h3><a name="c4">3.4. Статические методы</a></h3>

		<p>Статические методы получают имя вызывающего класса в первом параметре. Конструкторы - это просто статические методы:</p>

		<pre class="code">package Student;

sub new {
  my($class, $name) = @_;
  # ...
}
sub list_all {
  my($class) = @_;
  # ...
}

package main;
use Student;
Student-&gt;list_all();</pre>

		<p>Методы экземпляров могут вызывать статические методы с помощью$self-&gt;static_method():</p>

		<pre class="code">sub work {
  my($self) = @_;
  $self-&gt;list_all();
}</pre>

		<h3><a name="c5">3.5. Наследование</a></h3>

		<p>Наследование осуществляется при помощи use base 'Base::Class':</p>

		<pre class="code">package Student::Busy;
use base 'Student';

sub night_shift {
  my($self) = @_;
  $self-&gt;work();
}

sub sleep { # Перекрывает метод родительского класса
  my($self) = @_;
  $self-&gt;night_shift();
}</pre>

		<p>Все классы автоматически наследуют некую основополагающую функциональность, такую как isa или can, от класса UNIVERSAL. Также, если вы чувствуете навязчивое желание выстрелить себе в ногу с помощью множественного наследования, Perl не станет вас останавливать.</p>

		<h3><a name="c6">3.6. Строгие атрибуты экземпляров</a></h3>

		<p>Поскольку традиционный объект является просто ссылкой на хэш, вы можете воспользоваться любым именем атрибута и Perl не будет жаловаться:</p>

		<pre class="code">use Student;
my $amy = Student-&gt;new('Amy');
$amy-&gt;{gobbledegook} = 'какое-то значение'; # Работает</pre>

		<p>Часто хочется задать список допустимых атрибутов так, чтобы Perl завершался с ошибкой, если кто-то попытался воспользоваться неизвестным атрибутом. Это можно сделать при помощи прагмы fields:</p>

		<pre class="code">package Student;
use fields 'name',
           'registration',
           'grades';

sub new {
  my($class, $name) = @_;
  $self = fields::new($class); # Возвращает пустой "строгий" объект
  $self-&gt;{name} = $name; # Получаем доступ к атрибуту как обычно
  return $self; # $self уже благословлён
}

package main;
use Student;

my $clara = Student-&gt;new('Clara');
$clara-&gt;{name} = 'WonderClara'; # Работает
$clara-&gt;{gobbledegook} = 'foo'; # Не работает</pre>

		<h3><a name="c7">3.7. Памятка о принципе обобщённого доступа</a></h3>

		<p>Кто-то может воротить нос от того, каким образом я получаю доступ к атрибутам экземпляров в моих примерах. Писать $clara-&gt;{name} легко до тех пор, пока нужно только лишь получить сохранённое значение. Однако, каким образом нужно изменить пакет Student, если при доступе к атрибуту {name}, потребуется произвести какие-то вычисления (вроде сцепления полей {first_name} и {last_name}), что нужно сделать? Замена публичного интерфейс пакета и замена всех упоминаний $clara-&gt;{name} на $clara-&gt;get_name() не является приемлемым решением.</p>

		<p>По существу, остаётся лишь одна из двух возможностей:</p>

		<ul>
			<li>Можно воспользоваться tie<a name="btn2"><a href="#tn2"><sup>2</sup></a></a> для того, чтобы при обращении к скаляру $clara-&gt;{name} класса выполнить необходимые вычисления атрибута. Я считаю этот процесс утомительным в чистом Perl, однако вам стоит заглянуть на страницу perltie документации Perl и составить собственное впечатление.</li>

			<li>Использовать только методы доступа (также известные как геттеры и сеттеры) и сделать незаконным прямое обращение к атрибуту в вашем программном проекте. Лично я предпочитаю этот способ, потому что он позволяет сделать код красивее и предоставляет больше контроля над видимостью атрибутов для других классов. CPAN содержит различные модули, автоматизирующие создание методов доступа. Я хочу показать, как развернуть собственный генератор методов доступа в разделе Расширение языка.</li>
		</ul>

		<h2><a name="d">4. Импорт</a></h2>

		<p>Поскольку пакеты, импортированные во время компиляции, могут полностью менять игровое поле перед тем, как интерпретатор просмотрит оставшуюся часть вашего скрипта, импорт может быть исключительно мощным.</p>

		<h3><a name="d1">4.1. Параметры импорта</a></h3>

		<p>Вы можете передать параметры любому пакету, который вы используете:</p>

		<pre class="code">package Student;
use Some::Package 'param1', 'param2';</pre>

		<p>Каждый раз при использовании пакета все параметры, с которыми вы его используете, передаются статическому методу import из этого пакета:</p>

		<pre class="code">package Some::Package;
sub import {
  my($class, @params) = @_;
}</pre>

		<h3><a name="d2">4.2. Кто вызвал?</a></h3>

		<p>Функция caller() позволяет вам (среди всего прочего) находить, какой класс вызвал текущий метод:</p>

		<pre class="code">package Some::Package;

sub import {
  my($class, @params) = @_;
  print "Гляди, " . caller() . " пытается меня импортировать!";
}</pre>

		<h3><a name="d3">4.3. Расширение языка</a></h3>

		<p>Давайте соединим наши знания и напишем простые члены пакета, которые настраивают поля для вызывающего пакета и создают удобные методы доступа к этим полям:</p>

		<pre class="code">package members;

sub import {
  my($class, @fields) = @_;
  return unless @fields;
  my $caller = caller();
  
  # Построим код, который вычислим для вызывающего
  # Выполним вызов fields для вызывающего пакета
  my $eval = "package $caller;\n" .
             "use fields qw( " . join(' ', @fields) . ");\n";

  # Сгенерируем удобные методы доступа
  foreach my $field (@fields) {
    $eval .= "sub $field : lvalue { \$_[0]-&gt;{$field} }\n";
  }

  # Вычислим подготовленный код
  eval $eval;

  # $@ содержит возможные ошибки вычисления
  $@ and die "Ошибка настройки членов для $caller: $@";
}

# И ещё немного кода ниже...
package Student;
use members 'name',
            'registration',
            'grades';

sub new {
  my($class, $name) = @_;
  $self = fields::new($class);
  $self-&gt;{name} = $name;
  return $self;
}

package main;
my $eliza = Student-&gt;new('Eliza');
print $eliza-&gt;name;           # Гляди, мам, фигурных скобок нет! То же, что и $eliza-&gt;name()
$eliza-&gt;name = 'WonderEliza'; # Работает, потому что наш метод доступа является lvalue
print $eliza-&gt;name;           # Напечатает "WonderEliza"</pre>

		<h2><a name="e">5. Ценные ресурсы</a></h2>

		<ul>
			<li><a href="http://wiki.slowass.net/?PerlDesignPatterns">Шаблоны проектирования Perl</a></li>

			<li><a href="http://search.cpan.org/">Поиск CPAN</a></li>
		</ul>

		<h2><a name="f">6. Заключительные слова</a></h2>

		<p>Я рад, если это небольшое руководство оказалось для вас полезным. Если у вас есть вопросы или комментарии, <a href="mailto:jaz@netalive.org">задавайте их</a> (только не отправляйте мне ваши домашние задания).</p>

		<p>По теме заметки: я написал прагму под названием <a href="http://www.netalive.org/swsu/archives/2004/09/reformed_perl_t.html">Reformed Perl</a> - исправленный Perl, которая облегчает многие задачи ООП в Perl 5 и предоставляет намного более приятный синтаксис. <a href="http://www.netalive.org/swsu/archives/2004/09/reformed_perl_t.html">Посмотрите сами!</a></p>

		<h2><a name="g">7. Об авторе</a></h2>

		<p>Хеннинг Кох - студент Аугсбургского университета информатики и мультимедиа, Германия. Он ведёт блог о проектировании и технологиях  программного обеспечения по адресу <a href="http://www.netalive.org/swsu/">http://www.netalive.org/swsu/</a>.</p>

		<h2>8. Примечания переводчика</h2>

		<ol>
			<li><a name="tn1">В Perl объект создаётся на основе ссылки операцией bless, что переводится как "благословлять".</a><a href="#btn1">&uarr;</a></li>

			<li><a name="tn2">Операция tie - это, в некотором роде, родственник операции bless. Переводится как "связывать", превращает объект в структуру данных, с которой можно обращаться точно так же, как с хэшем, массивом или файловым дескриптором. Подробнее об этом можно почитать, например, тут: <a href="http://www.providerz.ru/articles/perl/perl_tie_change_hash_behavior.html">Изменение поведения хэша с использованием функции tie</a>.</a><a href="#btn2">&uarr;</a></li>
		</ol>

		<p>Решил перевести эту статью, потому что редко встретишь такую статью, в которой настолько компактно излагалось бы столько важной информации о программировании на Perl, дающей хотя бы поверхностное представление о действительной мощи этого языка.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Хеннинг Кох. Написание серьёзных приложений на Perl. Безусловный минимум, который вам необходимо знать, 2004">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

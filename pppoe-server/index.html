<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="pppoe,Debian" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2009-02-22 -->
		<title>Настройка PPPoE-сервера в Debian</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Настройка PPPoE-сервера в Debian</h1>

		<p>Продолжаю тему пакета RP-PPPoE. На этот раз я решил настроить PPPoE-сервер из этого пакета. PPPoE-сервер, как и клиент, может работать в двух режимах: в режиме ядра и в пространстве пользователя.</p>

		<p>Но прежде чем перейти к описанию настройки сервера, опишу настройки клиента. И клиент и сервер находятся в пакете pppoe Debian. Таким образом установка сервера и клиента весьма просты:</p>
		
		<pre class="console"># aptitude install pppoe</pre>

		<h2>1. Настройка тестового PPPoE-клиента</h2>

		<p>Клиент настраивался в режиме ядра, маршрут по-умолчанию не устанавливался, номер создаваемого интерфейса был прописан постоянным - 2.</p>

		<p>Ниже - содержимое файла /etc/ppp/peers/dsl-provider, содержащий настройки тестового клиента:</p>

		<pre class="code">user test
plugin rp-pppoe.so
eth1
noipdefault
usepeerdns
persist
noauth
#defaultroute
unit 2</pre>
		<p>Для пользователя test в файл /etc/ppp/chap-secrets добавим такую строчку:</p>

		<pre class="code">test            *               testpasswd      *</pre>

		<p>На этом настройка клиента закончена. После того, как будет настроен сервер, мы установим подключение при помощи команды:</p>

		<pre class="console"># pon dsl-provider</pre>

		<h2>2. Настройка PPPoE-сервера в пространстве пользователя</h2>

		<p>Тут особых сложностей тоже не возникло. В файле /etc/ppp/pppoe-server-options были прописаны следующие опции:</p>

		<pre class="code">auth
require-chap
ms-dns 81.30.199.5
ms-dns 81.30.199.94
noipdefault
noipx
nodefaultroute
noproxyarp
netmask 255.255.255.255
logfile /var/log/pppoe-server.log</pre>

		<p>Опция auth заставляет потребовать у удалённого клиента аутентификации, опция require-chap указывает способ аутентификации CHAP.</p>

		<p>Опции ms-dns передают клиенту IP-адреса DNS-серверов, которые клиент воспринимает если в его настройках указазана опция usepeerdns.</p>

		<p>Опция noipdefault не позвояет соглашаться с настройками IP-адресов, полученных от клиента, noipx отключает согласование протокола IPX, nodefaultroute запрещает добавлять маршрут по умолчанию через клиента, noproxyarp запрещает серверу создавать для клиентов ARP-записи на Ethernet-интерфейсах (эта опция нужна только если клиентам выдаются IP-адреса, пересекающиеся с IP-адресами Ethernet-сети, чтобы PPPoE-клиенты и компьютеры в локальной сети могли беспрепятственно обмениваться трафиком).</p>

		<p>Опция "netmask 255.255.255.255" задаёт маску PPP-соединения у клиента и сервера, опция <span class="code">logfile /var/log/pppoe-server.log</span> предписывает вести серверу журнал. Пользы от этого журнала не очень много, т.к. в нём нет отметок времени.</p>

		<p>По-умолчанию сервер передаёт в pppd также ещё и следующие опции: nodetach, noaccomp, nobsdcomp, nodeflate, nopcomp, novj, novjccomp, default-asyncmap.</p>

		<p>Все опции по-умолчанию имеют приоритет над опциями из файла /etc/ppp/pppoe-server-options. Все опции, кроме первой и последней, отключают различные виды сжатия. Первая и последняя опции, на мой взгляд, спорные. Первая указывает pppd не отделяться от управляющего терминала. Какой может быть управляющий терминал, если pppd запущен из демона, то есть из программы, которая сама не имеет управляющего терминала? Последняя опция предписывает pppd не согласовывать параметр asyncmap и принудительно экранировать все управляющие символы, что не имеет особого смысла, поскольку Ethernet-среда ни коим образом не интерпретирует управляющие символы. Возможно эта опция предназначена для DSL-линии. Она, будучи последовательной линией, может использовать асинхронный режим приёма/передачи, в котором приёмник сообщает передатчику о готовности или неготовности к приёму информации с помощью специальных символов XON или XOFF.</p>

		<p>Заведём тестового пользователя в файле /etc/ppp/chap-secrets на PPPoE-сервере, добавив строчку:</p>

		<pre class="code">test            *               testpasswd              192.168.0.2</pre>

		<p>Последнее поле сообщает IP-адрес, который будет назначен этому клиенту в случае успешной аутентификации.</p>

		<p>Теперь запустим сервер. У сервера есть несколько важных опций:</p>

		<ul>
			<li>-I - задаёт имя интерфейса, на котором сервер будет ожидать соединений,</li>

			<li>-L - задаёт собственный IP-адрес сервера внутри канала PPP,</li>

			<li>-p - позволяет задать файл, содержащий список IP-адресов, выдаваемых клиентам внутри канала PPP,</li>

			<li>-O - позволяет задать другой файл вместо используемого по умолчанию /etc/ppp/pppoe-server-options,</li>

			<li>-N - позволяет указать максимальное количество одновременных соединений, по умолчанию 64.</li>
		</ul>

		<p>Я запустил так:</p>

		<pre class="console"># pppoe-server -I eth1 -L 192.168.0.1</pre>

		<p>Сервер запускается и переходит в фоновый режим. После этого запускаем на другом компьютере PPPoE-клиента:</p>

		<pre class="console"># pon dsl-provider</pre>

		<p>Связь успешно установилась и на клиенте был создан интерфейс ppp2 с IP-адресами 192.168.0.2 и 192.168.0.1, на на сервере был создан интерфейс ppp0 с IP-адресами 192.168.0.1 и 192.168.0.2.</p>

		<p>Теперь можно проверить работу связи. Для этого я на клиенте запустил команду:</p>

		<pre class="console">$ ping -S 192.168.0.2 192.168.0.1</pre>

		<p>А на сервере запустил команду:</p>

		<pre class="console"># tcpdump -i ppp0</pre>

		<p>Можно было увидеть, что клиент получает от сервера отклики на эхо-запросы, а сервер принимает и отправляет ICMP-сообщения "echo request" и "echo reply".</p>

		<h2>3. Настройка PPPoE-сервера в режиме ядра</h2>

		<p>Здесь, казалось бы, всё просто: добавляем серверу опцию -k и вперёд, но оказалось всё не так просто. В Debian pppoe-server собран без поддержки режима ядра и наотрез отказывается принимать опцию -k. Я решил собрать pppoe самостоятельно из deb-src. Направление для мыслей задал вот этот багрепорт: <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=298185">#298185 - pppoe-server: invalid option -- k - Debian Bug report logs</a>. После долгого процесса копания по опциям получилось такое mini-how-to:</p>

		<p>Устанавливаем зависимости для построения pppoe:</p>

		<pre class="console"># apt-get build-dep pppoe</pre>

		<p>Скачиваем и распаковываем в текущий каталог исходники:</p>

		<pre class="console"># apt-get source pppoe</pre>

		<p>Переходим в каталог rp-pppoe-3.8/src и выполняем конфигурирование:</p>

		<pre class="console"># cd rp-pppoe-3.8/src
# ./configure</pre>

		<p>Теперь в только что созданном файле config.h нужно заменить строчку</p>

		<pre class="code">/* #undef HAVE_LINUX_KERNEL_PPPOE */</pre>

		<p>на строчку</p>

		<pre class="code">#define HAVE_LINUX_KERNEL_PPPOE 1</pre>

		<p>Теперь выходим из каталога src и выполняем сборку, указав путь к плагину rp-pppoe.so, который как раз и реализует поддержку PPPoE-сеансов на уровне ядра:</p>

		<pre class="console"># cd ..
# ./debian/rules PLUGIN_PATH=/usr/lib/pppd/2.4.4/rp-pppoe.so</pre>

		<p>Собираем пакет и устанавливаем его:</p>

		<pre class="console"># ./debian/rules binary
# cd ..
# dpkg -i pppoe_3.8-3_i386.deb</pre>

		<p>Заморозим пакет в системе, чтобы предотвратить его автоматическое обновление:</p>

		<pre class="console"># echo pppoe hold | dpkg --set-selections</pre>

		<p>С этого момента нужно как минимум при каждом обновлении системы просматривать список обновлений. Если для pppoe будет выпущено обновление, закрывающее уязвимость, необходимо будет собрать пакет из свежих исходников заново, снять фиксацию пакета в системе с помощью команды:</p>

		<pre class="console"># echo pppoe install | dpkg --set-selections</pre>

		<p>Затем заменить пакет новым и заново зафиксировать. Всё это - неизбежная плата за использование самосборного пакета. Конечно можно автоматизировать пересборку пакета, написав shell-скрипт, запускающий в нужной последовательности все указанные команды и заменяющий нужную строчку с помощью sed.</p>

		<p>Так или иначе, теперь в системе установлен пакет с PPPoE-сервером, позволяющим поддерживать PPPoE-соединения на уровне ядра. Для запуска сервера в этом режиме, к команде описанной в предыдущем разделе нужно добавить опцию -k:</p>

		<pre class="console"># pppoe-server -I eth1 -L 192.168.0.1 -k</pre>

		<p>Можно проверить связь так же, как это было описано выше, у меня всё заработало.</p>

		<p>Осталось написать стартовые скрипты для запуска PPPoE-сервера и добавить их в систему.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Настройка PPPoE-сервера в Debian">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

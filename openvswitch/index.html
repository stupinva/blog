<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="xen,jessie,xl,linux,debian,ovs" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2016-06-19 -->
		<title>Установка и настройка Open vSwitch в Debian</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Установка и настройка Open vSwitch в Debian</h1>

		<p>В <a href="../xen-altlinux/">прошлой заметке</a> я создал виртуальную машину с AltLinux, которая работает под управлением Xen. Там сетевой интерфейс виртуальной машины соединяется мостом с интерфейсом хост-машины (или вернее - домена-0).</p>

		<p>Такой способ настройки может оказаться не безопасным, если на интерфейсе имеется несколько VLAN, часть которых не должны быть доступны внутри виртуальной машины. В качестве примеров можно привести случай предоставления Xen-хостинга или попытку отделить друг от друга виртуальные машины, работающие в локальной сети и в интернете. Например, через VLAN 2 может быть доступна локальная сеть, а через VLAN 3 - сеть интернет. При том способе настройки, который был описан в прошлой статье, хозяин виртуальной машины, которая должна работать только в локальной сети, может настроить внутри виртуалки VLAN-интерфейс для доступа в интернет, прослушать трафик, попытаться подобрать свободный IP-адрес и получить таким образом доступ в интернет. Или другой пример - злоумышленник может получить доступ к виртуальной машине, доступной из сети интернет, настроить VLAN-интерфейс и продолжить взлом уже внутри локальной сети.</p>

		<p>Чтобы ограничить передаваемые в виртуальную машину VLAN, рассмотрим использование виртуального коммутатора Open vSwitch.</p>

		<h2>1. Установка Open vSwitch</h2>

		<p>Для установки виртуального коммутатора, нужно установить в систему всего-лишь один пакет:</p>

		<pre class="console"># apt-get install openvswitch-switch</pre>

		<h2>2. Настройка виртуального коммутатора средствами Debian</h2>

		<p>В составе пакета имеются скрипты для настройки коммутатора привычными для Debian средствами, через файл /etc/network/interfaces. Почитать о настройке можно в файле /usr/share/doc/openvswitch-switch/README.Debian.gz, открыв его, например, при помощи zless, или в статье <a href="http://www.opencloudblog.com/?p=240">Boot integration of the Openvswitch in Ubuntu</a>. Благодаря Open vSwitch, я смог избавиться от интерфейсов vlan и br, настроенных стандартными средствами Linux, и заменил их на функционально эквивалентные им интерфейсы Open vSwitch:</p>

		<pre class="code">auto ovs0
allow-ovs ovs0
iface ovs0 inet manual
  ovs_type OVSBridge
  ovs_ports eth0 ovs0-vlan2 ovs0-vlan3 ovs0-vlan4

allow-ovs0 eth0
iface eth0 inet manual
  ovs_type OVSPort
  ovs_bridge ovs0
  ovs_options vlan_mode=native-untagged tag=2 trunks=2,3,4

allow-ovs0 ovs0-vlan2
iface ovs0-vlan2 inet static
  ovs_bridge ovs0
  ovs_type OVSIntPort
  ovs_options tag=2
  address 169.254.254.1
  netmask 255.255.255.0
  
allow-ovs0 ovs0-vlan3
iface ovs0-vlan3 inet dhcp
  ovs_bridge ovs0
  ovs_type OVSIntPort
  ovs_options tag=3

allow-ovs0 ovs0-vlan4
iface ovs0-vlan4 inet static
  ovs_bridge ovs0
  ovs_type OVSIntPort
  ovs_options tag=4
  address 0.0.0.0
  netmask 255.255.255.0</pre>

		<p>Интерфейс ovs0 соответствует созданию одного виртуального коммутатора. При необходимости их можно создать несколько. В этот коммутатор подключается порт eth0, по которому могут передаваться тегированные пакеты для VLAN 3 и 4, а не тегированный трафик помечается как принадлежащий VLAN 2. Следующие три интерфейса соответствуют этим трём VLAN'ам.</p>

		<p>Если через интерфейсы, принадлежащие Open vSwitch, устанавливаются другие подключения, вроде pppoe или pptp, то эти интерфейсы можно упомянуть в опции ovs_ports после используемого им интерфейса. Далее останется только удалить опцию auto и добавить вместо неё опцию allow-<i>ovs0</i> для того, чтобы поднятие этого интерфейса происходило уже по команде от демона Open vSwitch. Интерфейсы поднимаются демоном в том порядке, в котором они указаны в опции ovs_ports.</p>

		<h2>3. Ручная настройка виртуального коммутатора</h2>

		<p>Для ручной настройки всего этого хозяйства сгодились бы следующие команды:</p>

		<pre class="console"># ovs-vsctl add-br ovs0
# ovs-vsctl add-port ovs0 eth0
# ovs-vsctl set port eth0 vlan_mode=native-untagged tag=2 trunks=2,3,4
# ovs-vsctl add-port ovs0 ovs0-vlan2 tag=2 -- set Interface ovs0-vlan2 type=internal
# ifconfig ovs0-vlan2 inet 169.254.254.1/24 up
# ovs-vsctl add-port ovs0 ovs0-vlan3 tag=3 -- set Interface ovs0-vlan3 type=internal
# dhclient ovs0-vlan3
# ovs-vsctl add-port ovs0 ovs0-vlan4 tag=4 -- set Interface ovs0-vlan4 type=internal
# ifconfig ovs0-vlan4 up</pre>

		<p>Чтобы удалить порт из коммутатора, можно воспользоваться такой командой:</p>

		<pre class="console"># ovs-vsctl del-port ovs0-vlan2</pre>

		<p>Чтобы удалить сам коммутатор, можно воспользоваться такой командой:</p>

		<pre class="console"># ovs-vsctl del-br ovs0</pre>

		<p>Посмотреть на текущие настройки виртуального коммутатора можно командой, которая уже была продемонстрирована выше:</p>

		<pre class="console"># ova-vsctl show</pre>

		<p>Стоит также отметить, что имена коммутаторов и портов могут быть совершенно произвольными. Названия ovs0 и ovs0-vlan2 и т.п. были даны лишь для наглядности. При этом, название интерфейса eth0 соответствует реальному интерфейсу, который нужно подключить к порту виртуального коммутатора, поэтому он фигурирует под своим настоящим именем.</p>

		<p>Описанное выше - лишь очень малая часть того, что умеет этот виртуальный коммутатор. Он поддерживает агрегацию портов, обнаружение петель, зеркалирование портов, сбор статистики о трафике на NetFlow-коллектор и многие другие вещи. Поддерживается даже специальный протокол OpenFlow, предназначенный для централизованного управления такими коммутаторами. Я же тут ограничился самыми простыми вещами, которые мне понадобились лишь для того, чтобы передать вовнутрь виртуальной машины под управлением Xen строго определённые VLAN.</p>

		<p>Сама коммутация пакетов происходит на уровне ядра, что обеспечивает максимальную производительность, но поддерживается и коммутация в пользовательском пространстве. В таком случае из-за частых переключений между режимами ядра и пользователя производительность должна оказаться уже не столь высокой.</p>

		<p>Вот так, например, можно убедиться в том, что по крайней мере некоторая часть openvswitch работает в пространстве ядра:</p>

		<pre class="console"># lsmod | grep vs
openvswitch            63932  0 
gre                    12777  1 openvswitch
vxlan                  35053  1 openvswitch
libcrc32c              12426  1 openvswitch</pre>

		<h2>4. Виртуальный коммутатор и Xen</h2>

		<p>Для того, чтобы включить в виртуальный коммутатор интерфейс виртуальной машины, работающей под управлением Xen, можно воспользоваться соответствующими настройками в файле конфигурации виртуальной машины. Например, вот фрагмент файла конфигурации /etc/xen/inet.cfg виртуальной машины inet:</p>

		<pre class="code">vif = ['script=vif-openvswitch,bridge=ovs0.2']</pre>

		<p>Таким образом виртуальная машина будет включена в нетегированный порт коммутатора в VLAN 2.</p>

		<p>Чтобы передать в виртуальную машину VLAN'ы 3 и 4 в тегированном режиме, можно воспользоваться следующим способом настройки:</p>

		<pre class="code">vif = ['script=vif-openvswitch,bridge=ovs0:3:4']</pre>

		<p>О других возможностях настройки сети в виртуальных машинах Xen можно почитать здесь: <a href="http://wiki.xenproject.org/wiki/Xen_Networking">Xen Networking</a></p>

		<p>P.S. 25 июня 2016. Внесён ряд правок, связанных с автоматическим восстановлением настроек при перезагрузке.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Установка и настройка Open vSwitch в Debian">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

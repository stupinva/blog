<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="python,перевод,flask" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2013-07-21 -->
		<title>Армин Роначер. Журналирование ошибок приложения на Flask, 2012</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Армин Роначер. Журналирование ошибок приложения на Flask, 2012</h1>

		<p>Перевод статьи: <a href="http://flask.pocoo.org/docs/errorhandling/">Logging Application Errors</a></p>

		<p>Автор: Армин Роначер (Armin Ronacher)</p>

		<p>Новинка версии 0.3.</p>

		<p>В приложениях и серверах иногда происходят ошибки. Рано или поздно вы увидите исключение на сервере в эксплуатации. Даже если ваш код на 100% правильный, вы всё равно будете время от времени видеть исключения. Почему? Потому что может сломаться что-то другое. Вот некоторые ситуации, в которых совершенный код может приводить к ошибкам на сервере:</p>

		<ul>
			<li>клиент завершил запрос раньше, а приложение по-прежнему ожидает поступления данных.</li>

			<li>сервер базы данных был перегружен и не смог обработать запрос.</li>

			<li>в файловой системе закончилось место.</li>

			<li>сломался жёсткий диск.</li>

			<li>перегружен сервер-бэкэнд.</li>

			<li>ошибка в используемой библиотеке.</li>

			<li>ошибка сетевого соединения сервера с другой системой.</li>
		</ul>

		<p>И это только небольшой список причин, который можно продолжить. Как же справляться с проблемами такого рода? По умолчанию, если приложение запущено в рабочем режиме, Flask покажет очень простую страницу и занесёт исключение в журнал.</p>

		<p>Но для обработки ошибок можно сделать и больше, если задать соответствующие настройки.</p>

		<h2>1. Письма об ошибках</h2>

		<p>Если приложение запущено на сервере в эксплуатации, по умолчанию не желательно показывать сообщения об ошибках. Почему? Flask пытается быть фреймворком, не требующим настройки. Куда он должен складывать сообщения об ошибках, если это не указано в настройках? Автоматически выбранное место может не подойти, потому что у пользователя может не быть прав на создание журналов в этом месте. К тому же, в большинстве никто не станет читать журналы небольших приложений.</p>

		<p>На деле я предполагаю, что вы не станете заглядывать в журнал ошибок, даже если настроите его, до тех пор пока вам не понадобится увидеть исключение для отладки проблемы, о которой сообщил пользователь. Более полезной может оказаться отправка письма в случае возникновения исключения. Тогда вы получите оповещение и сможете что-нибудь с ним сделать.</p>

		<p>Flask использует встроенную систему журналирования Python, и действительно может отправлять письма об ошибках, чем вы можете воспользоваться. Вот как можно настроить систему журналирования Flask для отправки писем об исключениях:</p>

		<pre class="code">ADMINS = ['yourname@example.com']

if not app.debug:
    import logging
    from logging.handlers import SMTPHandler
    mail_handler = SMTPHandler('127.0.0.1',
                               'server-error@example.com',
                               ADMINS, 'Сбой в приложении')
    mail_handler.setLevel(logging.ERROR)
    app.logger.addHandler(mail_handler)</pre>

		<p>Что это даст? Мы создали новый обработчик SMTPHandler, который отправит письма через почтовый сервер с IP-адресом 127.0.0.1 на все адреса из ADMINS с адреса server-error@example.com и с темой "Сбой в приложении". Если почтовый сервер требует авторизации, можно указать необходимые для неё данные. За информацией о том, как это сделать, обратитесь к документации на SMTPHandler.</p>

		<p>Мы также сообщили обработчику, что он должен отправлять письма только об ошибках или более важных сообщениях, потому что нам явно не нужны письма о предупреждениях или других бесполезных записях в журнале, которые могут появиться в процессе обработки запроса.</p>

		<p>Перед тем, как применить эти настройки на сервере в эксплуатации, обратитесь к разделу <a href="#logformat">Управление форматом журнала</a> ниже, чтобы в письма помещалась необходимая информация и вы не растерялись, получив письмо.</p>

		<h2>2. Журналирование в файл</h2>

		<p>Даже если вы получили письмо, вам скорее всего захочется посмотреть и на предупреждения в журнале. Хорошо бы сохранить как можно больше информации, полезной для отладки проблемы. Отметим, что ядро Flask само по себе не выдаёт предупреждений, поэтому вам самим нужно позаботиться о том, чтобы генерировать предупреждения в вашем коде, в случае если что-то пошло не так.</p>

		<p>Эта пара обработчиков поставляется в комплекте с системой журналирования, но не каждый из них подходит для начального журналирования ошибок. Наиболее интересными могут показаться следующие:</p>

		<ul>
			<li>FileHandler - ведёт журнал ошибок в файле.</li>

			<li>RotatingFileHandler - ведёт журнал ошибок в фале и создаёт новый файл после определённого количества сообщений.</li>

			<li>NTEventLogHandler - использует системный журнал событий Windows. Может пригодиться при развёртывании приложения на Windows-компьютере.</li>

			<li>SysLogHandler - отправляет сообщения в syslog, системный журнал UNIX.</li>
		</ul>

		<p>Как только вы подберёте подходящий обработчик журнала, можете настроить обработчик SMTP из примера выше. Просто убедитесь в том, что снизили порог критичности сообщений (я рекомендую WARNING):</p>

		<pre class="code">if not app.debug:
    import logging
    from themodule import TheHandlerYouWant
    file_handler = TheHandlerYouWant(...)
    file_handler.setLevel(logging.WARNING)
    app.logger.addHandler(file_handler)</pre>

		<h2 target="logformat">3. Управление форматом журнала</h2>

		<p>По умолчанию обработчик будет лишь записывать строку с сообщением в файл или отправлять эту строку по почте. Записи журнала содержат больше информации и стоит настроить обработчик так, чтобы он содержал больше полезной информации, по которой можно понять, что случилось и, что более важно, где это произошло.</p>

		<p>Средство форматирования можно настроить при помощи строки формата. Отметим, что отчёт о трассировке добавляется к записи в журнале автоматически, для этого не требуется каких-то специальных настроек в строке формата.</p>

		<p>Вот примеры настройки:</p>

		<h3>3.1. Журналирование на почту</h3>

		<pre class="code">from logging import Formatter

mail_handler.setFormatter(Formatter('''
Message type: %(levelname)s
Location: %(pathname)s:%(lineno)d
Module: %(module)s
Function: %(funcName)s
Time: %(asctime)s
Message:
%(message)s
'''))</pre>

		<h3>3.2. Журналирование в файл</h3>

		<pre class="code">from logging import Formatter
file_handler.setFormatter(Formatter(
'%(asctime)s %(levelname)s: %(message)s '
'[in %(pathname)s:%(lineno)d]'
))</pre>

		<h2>4. Сложное форматирование журналов</h2>

		<p>Вот список полезных переменных форматирования для подстановки в строку формата. Отметим, что этот список не полный, полный список можно найти в официальной документации пакета журналирования.</p>

		<table>
			<thead>
				<th>Формат</th>

				<th>Описание</th>
			</thead>

			<tbody>
				<tr>
					<td>%(levelname)s</td>

					<td>Уровень серьёзности сообщения ('DEBUG' - отладочное, 'INFO' - информационное, 'WARNING' - предупреждение, 'ERROR' - ошибка, 'CRITICAL' - критичное).</td>
				</tr>

				<tr>
					<td>%(pathname)s</td>

					<td>Полный путь к файлу с исходным текстом, из которого была вызвана функция журналирования (если доступен).</td>
				</tr>

				<tr>
					<td>%(filename)s</td>

					<td>Имя файла с исходным текстом.</td>
				</tr>

				<tr>
					<td>%(module)s</td>

					<td>Модуль (часть имени файла).</td>
				</tr>

				<tr>
					<td>%(funcName)s</td>

					<td>Имя функции, из который была вызвана функция журналирования.</td>
				</tr>

				<tr>
					<td>%(lineno)d</td>

					<td>Номер строки в файле исходного текста, в которой произошёл вызов функции журналирования (если доступна).</td>
				</tr>

				<tr>
					<td>%(asctime)s</td>

					<td>Время создания записи в журнале в человеко-читаемом виде. По умолчанию используется формат "2003-07-08 16:49:45,896" (числа после запятой - это миллисекунды). Можно изменить путём создания класса-наследника от formatter и заменой метода formatTime().</td>
				</tr>

				<tr>
					<td>%(message)s</td>

					<td>Журнальное сообщение, полученное из выражения msg % args</td>
				</tr>
			</tbody>
		</table>

		<p>Если вы хотите выполнить тонкую настройку форматирования, нужно создать класс-наследник от formatter. formatter имеет три полезных метода:</p>

		<h3>4.1. format():</h3>

		<p>Занимается собственно форматированием. Принимает объект LogRecord и возвращает отформатированную строку.</p>

		<h3>4.2. formatTime():</h3>

		<p>Вызывается для форматирования asctime. Если нужно задать другой формат времени, можно заменить этот метод.</p>

		<h3>4.3. formatException():</h3>

		<li>Вызывается для форматирования исключений. Принимает кортеж exc_info и возвращает строку. В большинстве случаев подойдёт метод по умолчанию, поэтому скорее всего вам не потребуется его заменять.</li>

		<p>За более подробной информацией обратитесь к официальной документации.</p>

		<h2>5. Другие библиотеки</h2>

		<p>Таким образом мы настроили журналирование событий, порождаемых самим приложением. Другие библиотеки могут вести собственный журнал. Например, SQLAlchemy широко использует журналирование в собственном ядре. Хотя этот способ пригоден для настройки сразу всех средств журналирования в пакете logging, пользоваться им не рекомендуется. Может возникнуть ситуация, когда нужно различать приложения, работающие в пределах одного интерпретатора Python, но  будет невозможно сделать для них отдельные настройки журналирования.</p>

		<p>Вместо этого рекомендуется выяснить, какие средства журналирования нужны, получить их с помощью функции getLogger() и перебрать все присоединённые к ним обработчики:</p>

		<pre class="code">from logging import getLogger
loggers = [app.logger, getLogger('sqlalchemy'),
           getLogger('otherlibrary')]

for logger in loggers:
    logger.addHandler(mail_handler)
    logger.addHandler(file_handler)</pre>

		<h2>6. Отладка ошибок приложения</h2>

		<p>Для приложений в эксплуатации настройте журналирование и уведомления так, как описано в разделе Журналирование ошибок приложения. Этот раздел предоставит указания для отладки конфигурации развёртывания и более глубокого исследования с использованием полнофункционального отладчика Python.</p>

		<h2>7. В случае сомнений запускайте вручную</h2>

		<p>Возникли проблемы с настройкой приложения в эксплуатации? Если имеется доступ к командной строке на сервере, проверьте, можете ли вы запустить приложение вручную из командной строки в режиме разработки. Убедитесь, что запустили его под той же учётной записью, под которой оно установлено, чтобы отследить ошибки, связанные с неправильной настройкой прав доступа. Можете воспользоваться встроенным во Flask сервером разработки, передав ему аргумент debug=True на сервере эксплуатации, что может помочь в отлове проблем с настройками, но убедитесь, что делаете это временно в управляемом окружении. Не запускайте приложение в эксплуатацию с аргументом debug=True.</p>

		<h2>8. Работа с отладчиками</h2>

		<p>Для более глубокого исследования можно выполнить трассировку кода. Flask содержит отладчик в стандартной поставке (смотрите <a href="http://flask.pocoo.org/docs/quickstart/#debug-mode">Режим отладки</a>). Если вам нравится пользоваться другим отладчиком Python, учтите, что они могут мешать друг другу. Можно указать несколько опций, чтобы использовать ваш любимый отладчик:</p>

		<ul>
			<li>debug - указывает, нужно ли включить режим отладки и захват исключений.</li>

			<li>use_debugger - указывает, нужно ли использовать отладчик, встроенный  во Flask.</li>

			<li>use_reloader - указывает, нужно ли перезагружать и перезапускать процесс, если произошло исключение.</li>
		</ul>

		<p>Опция debug должна иметь значение True (то есть, исключения должны захватываться), для того чтобы учитывались две следующие опции.</p>

		<p>Если вы используете Aptana/Eclipse для отладки, вам нужно установить обе опции use_debugger и use_reloader в False.</p>

		<p>Возможно, лучшие всего настроить эти опции в файле config.yaml (измените блок, так как вам нужно):</p>

		<pre class="code">FLASK:
    DEBUG: True
    DEBUG_WITH_APTANA: True</pre>

		<p>В точке входа в ваше приложение (main.py), нужно написать что-то вроде этого:</p>

		<pre class="code">if __name__ == "__main__":
    # Чтобы разрешить aptana получать ошибки, задайте use_debugger=False
    app = create_app(config="config.yaml")
    if app.debug: use_debugger = True
    try:
        # Отключаем отладчик Flask, если запрошено использование внешнего отладчика
        use_debugger = not(app.config.get('DEBUG_WITH_APTANA'))
    except:
        pass
    app.run(use_debugger=use_debugger, debug=app.debug,
            use_reloader=use_debugger, host='0.0.0.0')</pre>

		<h2>9. Примечания переводчика</h2>

		<p><a href="https://flask-russian-docs.readthedocs.org/ru/latest/errorhandling.html">Этот</a> и другие переводы можно найти на <a href="https://flask-russian-docs.readthedocs.org/">сайте проекта перевода документации по Flask</a>. Автор проекта - Виталий Кузьмин aka ferm32.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Армин Роначер. Журналирование ошибок приложения на Flask, 2012">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="jinja2,python,перевод,flask" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2013-05-05 -->
		<title>Армин Роначер. Шаблоны Jinja2 во Flask, 2012</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Армин Роначер. Шаблоны Jinja2 во Flask, 2012</h1>

		<p>Перевод статьи: <a href="http://flask.pocoo.org/docs/templating/">Templates</a></p>

		<p>Автор: Армин Роначер (Armin Ronacher)</p>

		<p>Flask использует в качестве системы шаблонизации Jinja2. Можно использовать другие системы шаблонизации, но для запуска Flask всё равно необходимо установить Jinja2. Это необходимо для использования дополнительных возможностей. Расширения могут зависеть от наличия Jinja2.</p>

		<p>Этот раздел предоставляет лишь краткое описание интеграции Jinja2 во Flask. Если вам нужна информация о синтаксисе самой системы шаблонизации, за более подробной информацией обратитесь к официальной <a href="http://jinja.pocoo.org/2/documentation/templates">документации по шаблонам Jinja2</a>.</p>

		<h2>1. Установка Jinja</h2>

		<p>По умолчанию Flask настраивает Jinja2 следующим образом:</p>

		<ul>
			<li>включено автоматическое экранирование для всех шаблонов, с раширениями .html, .htm, .xml, .xhtml</li>

			<li>шаблон может включать или отключать автоматическое экранирование при помощи тега {% autoescape %}.</li>

			<li>Flask добавляет пару функций и хелперов в контекст Jinja2, дополнительно к значениям, имеющимся по умолчанию.</li>
		</ul>

		<h2>2. Стандартный контекст</h2>

		<p>По умолчанию из шаблонов Jinja2 доступны следующие глобальные переменные:</p>

		<table>
			<thead>
				<tr>
					<th>Переменная</th>

					<th>Описание</th>
				</tr>
			</thead>

			<tbody>
				<tr>
					<td>config</td>

					<td>
						<p>Объект текущей конфигурации (flask.config)</p>
						<p><i>Новинка версии 0.6.</i></p>
					</td>
				</tr>

				<tr>
					<td>request</td>

					<td>Объект текущего запроса (flask.request)</td>
				</tr>

				<tr>
					<td>session</td>

					<td>Объект текущего сеанса (flask.session)</td>
				</tr>

				<tr>
					<td>g</td>

					<td>Связанный с запросом объект с глобальными переменными (flask.g)</td>
				</tr>

				<tr>
					<td>url_for()</td>

					<td>Функция flask.url_for()</td>
				</tr>

				<tr>
					<td>get_flashed_messages()</td>

					<td>Функция flask.get_flashed_messages()</td>
				</tr>
			</tbody>
		</table>

		<h2>3. Контекстное поведение Jinja</h2>

		<p>Эти переменные добавляются к переменным контекста, но это не глобальные переменные. Отличие заключается в том, что по умолчанию эти переменные отсутствуют в контексте импортируемых шаблонов. Отчасти это сделано для повышения производительности, отчасти - из-за предпочтения явного поведения неявному.</p>

		<p>Какое это имеет значение? Если вам нужно получить доступ из макроса к объекту запроса, есть две возможности:</p>

		<ol>
			<li>явным образом передать объект запроса или его атрибут в макрос в качестве параметра.</li>

			<li>импортировать макрос с контекстом, указав ключевые слова "with context".</li>
		</ol>

		<p>Импорт с контекстом выглядит следующим образом:</p>

		<pre class="code">{% from '_helpers.html' import my_macro with context %}</pre>

		<h2>4. Стандартные фильтры</h2>

		<p>В дополнение к собственным фильтрам Jinja2, доступны следующие фильтры:</p>

		<p><b><i>tojson()</i></b></p>

		<p>Эта функция конвертирует переданный объект в JSON-представление. Это может быть полезно, когда нужно на лету сгенерировать JavaScript.</p>

		<p>Отметим, что внутри тегов script не должно производиться экранирование, поэтому убедитесь в том, что отключили экранирование при помощи фильтра |safe, если собираетесь использовать фильтр tojson внутри тегов script:</p>

		<pre class="code">&lt;script type=text/javascript&gt;
  doSomethingWith({{ user.username|tojson|safe }});
&lt;/script&gt;</pre>

		<p>Фильтр |tojson правильно экранирует прямую косую черту.</p>

		<h2>5. Управление автоэкранированием</h2>

		<p>Автоэкранирование - это автоматическое экранирование специальных символов. Специальными символами в HTML (а также в XML и в XHTML) являются &amp;, &gt;, &lt;, " и '. Поскольку эти символы имеют особое значение в документах, для использования в тексте их нужно заменить на так называемые "сущности". Если этого не сделать, это не только может повлиять на невозможность использования этих символов пользователем, но и привести к проблемам с безопасностью (см. <a href="http://flask.pocoo.org/docs/security/#xss">Кросс-сайтовый скриптинг - XSS</a>).</p>

		<p>Однако, иногда в шаблонах может потребоваться отключить автоэкранирование. Это может понадобиться, если нужно явным образом вставить в страниц фрагмент HTML, если фрагмент поступил из системы генерации безопасного HTML, например, из преобразователя markdown в HTML.</p>

		<p>Для достижения этого есть три способа:</p>

		<ul>
			<li>В коде Python обернуть строку HTML в объект Markup перед передачей в шаблон. Это рекомендуемый способ.</li>

			<li>Внутри шаблона, воспользовавшись фильтром |safe для явной отметки строки, как безопасного HTML ({{ myvariable|safe }})</li>

			<li>Временно отключить систему автоэкранирования.</li>
		</ul>

		<p>Для отключения системы автоэкранирования в шаблонах можно воспользоваться блоком {% autoescape %}:</p>

		<pre class="code">{% autoescape false %}
  &lt;p&gt;здесь автоэкранирование отключено
  &lt;p&gt;{{ will_not_be_escaped }}
{% endautoescape %}</pre>

		<p>Соблюдайте осторожность и всегда следите за переменными, которые  помещаете в этот блок.</p>

		<h2>6. Регистрация фильтров</h2>

		<p>Если нужно зарегистрировать собственные фильтры в Jinja2, у есть два способа. Можно просто поместить их вручную в атрибут jinja_env приложения или использовать декоратор template_filter().</p>

		<p>Следующие примеры делают одно и то же, переставляя элементы объекта в обратном порядке:</p>

		<pre class="code">@app.template_filter('reverse')
def reverse_filter(s):
    return s[::-1]

def reverse_filter(s):
    return s[::-1]

app.jinja_env.filters['reverse'] = reverse_filter</pre>

		<p>При использовании декоратора указывать аргумент не обязательно, если вы хотите чтобы имя фильтра совпадало с именем функции. Однажды зарегистрировав фильтр, вы можете использовать его в шаблонах точно так же, как и встроенные фильтры Jinja2, например, если имеется список Python, имеющий в контексте имя mylist:</p>

		<pre class="code">{% for x in mylist | reverse %}
{% endfor %}</pre>

		<h2>7. Процессоры контекста</h2>

		<p>Для автоматической вставки в контекст шаблона новых переменных существуют процессоры контекста Flask. Процессоры контекста запускаются перед отрисовкой шаблона и позволяют добавить новые переменные в контекст. Процессор контекста - это функция, возвращающая словарь, который будет объединён с контекстом шаблона, для всех шаблонов в приложении. Например, для app:</p>

		<pre class="code">@app.context_processor
def inject_user():
    return dict(user=g.user)</pre>

		<p>Процессор контекста, приведённый выше, сделает переменную g.user доступной из шаблона под именем user. Этот пример не очень интересен, поскольку g и так доступна в шаблонах, но даёт представление о том, как это работает.</p>

		<p>Процессор контекста может передавать в шаблон не только переменные, но и функции (поскольку Python позволяет передавать функции):</p>

		<pre class="code">@app.context_processor
def utility_processor():
    def format_price(amount, currency=u'€'):
        return u'{0:.2f}{1}.format(amount, currency)
    return dict(format_price=format_price)</pre>

		<p>Вышеприведённый процессор контекста передаст функцию format_price во все шаблоны:</p>

		<pre class="code">{{ format_price(0.33) }}</pre>

		<p>Вы также можете встроить format_price как фильтр шаблона (см. выше раздел Регистрация фильтров), но этот пример демонстрирует, как передавать функции в контекст шаблона.</p>

		<h2>8. Примечания переводчика</h2>

		<p><a href="https://flask-russian-docs.readthedocs.org/en/latest/templating.html">Этот</a> и другие переводы можно найти на <a href="https://flask-russian-docs.readthedocs.org/">сайте проекта перевода документации по Flask</a>. Автор проекта - Виталий Кузьмин aka ferm32.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Армин Роначер. Шаблоны Jinja2 во Flask, 2012">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="zabbix,diskstats,debian,linux" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2017-06-04 -->
		<title>Статистика ввода-вывода diskstats в Linux через Zabbix</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Статистика ввода-вывода diskstats в Linux через Zabbix</h1>

		<p>Как и во FreeBSD, для оценки производительности дисковой подсистемы Linux тоже можно воспользоваться утилитой iostat. Однако, в отличие от версии iostat из FreeBSD, в iostat из Linux нет опции, позволяющей выводить накопленные значения счётчиков. Чтобы получить полную статистику за интересующий нас интервал времени, можно воспользоваться файлом /proc/diskstats из специальной файловой системы /proc. Эта файловая система позволяет узнавать состояние различных подсистем ядра Linux и менять некоторые настройки.</p>

		<p>Всё то, что я писал относительно FreeBSD, справедливо и для Linux: полную картину нагрузки на дисковую подсистему можно получить только собирая статистику за достаточно долгий срок. Имея полную статистику за неделю, можно найти периоды максимальной нагрузки и связать их с периодически выполняющимися в системе задачами, что позволит, например, подобрать оптимальное время запуска процедуры резервного копирования.</p>

		<p>В этой статье речь пойдёт о том, как собирать статистику из файла /proc/diskstats в Zabbix. Этот метод я считаю более правильным, чем встречающиеся в интернете шаблоны, использующие для сбора статистики программу iostat, работающую некоторое время. Как я уже говорил, во-первых, такой способ не позволяет собрать статистику в промежутках между запусками команды, а во-вторых, приводит к необходимости использовать промежуточный файл, чтобы не ждать сбора статистики при запросе значения каждого отдельного счётчика.</p>

		<p>Прежде чем что-то делать, ознакомимся с краткой документацией на этот файл по ссылке <a href="https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats">https://www.kernel.org/doc/Documentation/ABI/testing/procfs-diskstats</a>. Значения столбцов этого файла таковы:</p>

		<ol type="1">
			<li>старший номер устройства (номер драйвера),</li>

			<li>младший номер устройства (порядковый номер устройства, управляемого этим драйвером),</li>

			<li>имя устройства в файловой системе /dev,</li>

			<li>количество успешно выполненных операций чтения,</li>

			<li>количество объединённых операций чтения,</li>

			<li>количество прочитанных секторов,</li>

			<li>время, потраченное на чтение, в миллисекундах,</li>

			<li>количество успешно выполненных операций записи,</li>

			<li>количество объединённых операций записи,</li>

			<li>количество записанных секторов,</li>

			<li>время, потраченное на запись, в миллисекундах,</li>

			<li>количество активных операций ввода-вывода (фактически - длина очереди транзакций),</li>

			<li>время, потраченное на выполнение операций ввода-вывода, в миллисекундах,</li>

			<li>взвешенное время выполнения операций ввода-вывода, в миллисекундах.</li>
		</ol>

		<p>В этом файле имеется ссылка на ещё один документ - <a href="https://www.kernel.org/doc/Documentation/iostats.txt">https://www.kernel.org/doc/Documentation/iostats.txt</a>. В документе описываются те же самые колонки, но в нём пропущены первые три колонки, в которых указывается информация о самом диске. Применительно к столбцам файла /proc/diskstats там написано следующее:</p>

		<ol type="1">
			<li>старший номер устройства (номер драйвера),</li>

			<li>младший номер устройства (порядковый номер устройства, управляемого этим драйвером),</li>

			<li>имя устройства в файловой системе /dev,</li>

			<li>количество выполненных операций чтения - общее количество успешно завершённых операций чтения,</li>

			<li>количество объединённых операций чтения - операции чтения соседних областей могут быть объединены друг с другом для повышения эффективности. Две операции чтения 4 килобайт можно объединить в одну операцию чтения 8 килобайт, прежде чем команда будет передана на диск. Такая операция будет поставлена в очередь и выполнена как одна операция. Это поле позволяет узнать, как часто происходит объединение операций,</li>

			<li>количество прочитанных секторов - общее количество успешно прочитанных секторов,</li>

			<li>время, потраченное на чтение, в миллисекундах - общее количество миллисекунд, потраченных всеми операциями чтения (замеренное между __make_request() и end_that_request_last()),</li>

			<li>количество выполненных операций записи - общее количество успешно завершённых операций записи,</li>

			<li>количество объединённых операций записи - см. описание поля 5,</li>

			<li>количество записанных секторов - общее количество успешно записанных секторов,</li>

			<li>время, потраченное на запись, в миллисекундах - общее количество миллисекунд, потраченных всеми операциями записи (замеренное между __make_request() и end_that_request_last()),</li>

			<li>количество активных операций ввода-вывода - единственное поле, которое сбрасывается в ноль. Увеличивается на единицу, когда запрос попадает в соответствующую структуру request_queue и уменьшается на единицу, когда этот запрос завершается,</li>

			<li>время, потраченное на выполнение операций ввода-вывода, в миллисекундах - это поле увеличивается, пока поле 12 отличается от нуля,</li>

			<li>взвешенное время выполнения операций ввода-вывода, в миллисекундах - это поле увеличивается с началом каждой операции ввода-вывода, завершением операции ввода-вывода, объединением операций ввода-вывода или при чтении этой статистики. Количество активных операций ввода-вывода (поле 12), помноженное на количество миллисекунд, потраченных на ввод-вывод с момента последнего обновления этого поля. Это поле позволяет легко оценить как время завершения ввода-вывода, так и время ожидания операции ввода-вывода в очереди.</li>
		</ol>

		<p>Итак, что из этого удалось понять и что не удалось понять:</p>

		<ul>
			<li>поле 12 не является накопительным и содержит текущее значение количества операций в очереди,</li>

			<li>точный смысл поля 14 понять не удалось, будем считать что там находится некое "взвешенное" значение, по смыслу аналогичное полю 13,</li>

			<li>размер сектора в полях 6 и 10 не известен.</li>
		</ul>

		<p>На вопрос о размере сектора я нашёл очень подробный ответ <a href="https://stackoverflow.com/questions/37248948/how-to-get-disk-read-write-bytes-per-second-from-proc-in-programming-on-linux#38136179">How to get disk read/write bytes per second from /proc in programming on linux?</a>, суть которого сводится к тому, что размер сектора в этом файле жёстко зафиксирован и всегда равен 512 байтам.</p>

		<p>Теперь приступим к настройке Zabbix-агента. Для этого впишем в его файл конфигурации /etc/zabbix/zabbix_agentd.conf следующие строки:</p>

		<pre class="code">UserParameter=diskstats.discovery,/usr/bin/awk 'BEGIN { printf "{\"data\":["; } { if (NR &gt; 1) printf ","; printf "{\"{#DEVNAME}\":\"" $3 "\"}"; } END { printf "]}"; }' /proc/diskstats
UserParameter=diskstats.read.ops[*],/usr/bin/awk '$$3 == "$1" { print $$4; }' /proc/diskstats
UserParameter=diskstats.read.merged[*],/usr/bin/awk '$$3 == "$1" { print $$5; }' /proc/diskstats
UserParameter=diskstats.read.bytes[*],/usr/bin/awk '$$3 == "$1" { print 512 * $$6; }' /proc/diskstats
UserParameter=diskstats.read.duration[*],/usr/bin/awk '$$3 == "$1" { print $$7; }' /proc/diskstats
UserParameter=diskstats.write.ops[*],/usr/bin/awk '$$3 == "$1" { print $$8; }' /proc/diskstats
UserParameter=diskstats.write.merged[*],/usr/bin/awk '$$3 == "$1" { print $$9; }' /proc/diskstats
UserParameter=diskstats.write.bytes[*],/usr/bin/awk '$$3 == "$1" { print 512 * $$10; }' /proc/diskstats
UserParameter=diskstats.write.duration[*],/usr/bin/awk '$$3 == "$1" { print $$11; }' /proc/diskstats
UserParameter=diskstats.queue.length[*],/usr/bin/awk '$$3 == "$1" { print $$12; }' /proc/diskstats
UserParameter=diskstats.busy.duration[*],/usr/bin/awk '$$3 == "$1" { print $$13; }' /proc/diskstats
UserParameter=diskstats.transactions.duration[*],/usr/bin/awk '$$3 == "$1" { print $$14; }' /proc/diskstats</pre>

		<p>После внесения изменений в файл конфигурации Zabbix-агента, не забудьте его перезапустить:</p>

		<pre style="background-color: black; color: white"># /etc/init.d/zabbix-agent restart</pre>

		<p>Я подготовил два варианта шаблона:</p>

		<ul>
			<li><a href="Template_App_diskstats_Linux.xml">Template_App_diskstats_Linux.xml</a> - шаблон с элементами данных типа "Zabbix-агент"</li>

			<li><a href="Template_App_diskstats_Linux_Active.xml">Template_App_diskstats_Linux_Active.xml</a> - шаблон с элементами данных типа "Zabbix-агент (активный)"</li>
		</ul>

		<p>В шаблоне имеется правило низкоуровневого обнаружения, которое находит все дисковые устройства, статистику по которым выдаёт diskstats:</p>

		<img src="diskstats_lld.png" />

		<p>Если часть устройств кажутся вам лишними, в настройках правила обнаружения на вкладке "Фильтр" можно задать регулярное выражение, которое будет совпадать только с интересующими вас файлами дисковых устройств.</p>

		<p>Для каждого найденного устройства создаются одиннадцать элементов данных, соответствующих колонкам производительности диска из файла diskstats:</p>

		<img src="diskstats_itemprototypes.png" />

		<p>Страница последних данных для одного из дисков выглядят следующим образом:</p>

		<img src="diskstats_lastdata.png" />

		<p>Элемент данных с названием "Загрузка диска" показывает процент времени, в течение которого диск занимается обработкой хотя бы одной транзакции.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Статистика ввода-вывода diskstats в Linux через Zabbix">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

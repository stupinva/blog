<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="osm2pgsql,postgresql,josm,mapnik,postgis" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2012-08-19 -->
		<title>Тайловый сервер - что с ним делать?</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Тайловый сервер - что с ним делать?</h1>

		<p>В прошлых заметках <a href="../mapnik-part1/">Подготовка карт для генератора тайлов Mapnik</a>, <a href="../mapnik-part2/">Настройка базы данных для генератора тайлов Mapnik</a>, <a href="../mapnik-part3/">Установка генератора тайлов Mapnik</a> и <a href="../mapnik-part4/">Установка renderd и mod_tile - системы отрисовки тайлов по запросу</a> мы настроили обычный тайловый сервер. Однако, от одного лишь просмотра карт толку мало - ведь то же самое без лишних усилий можно увидеть и на официальном сайте <a href="http://openstreetmap.org">OpenStreetMap</a>.</p>

		<h2>1. Добавление локальной информации</h2>

		<p>Для того, чтобы на карту можно было вносить локальную информацию, можно настроить локальный веб-сайт OpenStreetMap и подключаясь к нему с помощью редактора JOSM, редактировать имеющуюся информацию. Я пробовал устанавливать Ruby и Rails и мне даже удалось запустить локальный веб-сайт, однако работал он очень медленно, а ускорить его работу мне не удалось - не хватило знаний Ruby on Rails и времени, чтобы в нём разобраться.</p>

		<p>Хотя, этот вариант в любом случае кажется мне не самым лучшим. Ведь в таком варианте настройки нельзя будет отделить локальные данные от данных, загруженных из проекта OpenStreetMap. Затрудняется процедура обновления карт OpenStreetMap - ведь нужно оставить локально внесённые данные, обновив при этом всё остальное.</p>

		<p>Поэтому я выбрал другой вариант - локальные данные будут храниться в OSM-файле, который можно редактировать с помощью уже знакомого нам редактора JOSM. Локальной информацией может быть, например, информация с расположением торговых точек в случае магазина, с расположением банкоматов в случае банка, платёжных терминалов, телефонов-автоматов, wifi-точек, зон ответственности развозчиков пиццы и т.п.</p>

		<p>Этот OSM-файл сразу после редактирования можно импортировать в отдельную базу данных. А для того, чтобы Mapnik отображал информацию из локальной базы данных, нужно добавить в файл стилей /etc/mapnik-osm-data/osm.xml настройки для подключения к новой базе данных и написать стиль отрисовки объектов из неё.</p>

		<p>Документацию по написанию файлов стилей можно найти здесь: <a href="https://github.com/mapnik/mapnik/wiki/XMLConfigReference">Mapnik configuration XML</a>.</p>

		<p>Вот пример фрагмента файла osm.xml, в котором задаётся стиль отображения некоего зонального деления территорий, берущегося из базы данных zones:</p>

		<pre class="code">&lt;Style name="zones"&gt;
  &lt;Rule&gt;
    &amp;maxscale_zoom0;
    &amp;minscale_zoom10;
  &lt;/Rule&gt;

  &lt;Rule&gt;
    &amp;maxscale_zoom9;
    &amp;minscale_zoom11;
    &lt;Filter&gt;not ([name] = '') and [area] = 'yes'&lt;/Filter&gt;
    &lt;LineSymbolizer stroke="#000000" stroke-opacity="1" stroke-width="1" stroke-linecap="round"/&gt;
  &lt;/Rule&gt;

  &lt;Rule&gt;
    &amp;maxscale_zoom12;
    &amp;minscale_zoom13;
    &lt;Filter&gt;not ([name] = '') and [area] = 'yes'&lt;/Filter&gt;
    &lt;LineSymbolizer stroke="#000000" stroke-opacity="1" stroke-width="2" stroke-linecap="round"/&gt;
    &lt;TextSymbolizer size="10" allow-overlap="yes" fill="#000000" fontset-name="book-fonts" opacity="1" placement="interior"&gt;[name]&lt;/TextSymbolizer&gt;
  &lt;/Rule&gt;

  &lt;Rule&gt;
    &amp;maxscale_zoom14;
    &amp;minscale_zoom19;
    &lt;Filter&gt;not ([name] = '') and [area] = 'yes'&lt;/Filter&gt;
    &lt;LineSymbolizer stroke="#000000" stroke-opacity="1" stroke-width="4" stroke-linecap="round"/&gt;
    &lt;TextSymbolizer size="20" allow-overlap="yes" fill="#000000" fontset-name="book-fonts" opacity="1" placement="interior"&gt;[name]&lt;/TextSymbolizer&gt;
  &lt;/Rule&gt;
&lt;/Style&gt;

&lt;Layer name="zones" status="on" srs="&amp;srs900913;"&gt;
  &lt;StyleName&gt;zones&lt;/StyleName&gt;
  &lt;Datasource&gt;
    &lt;Parameter name="table"&gt;(select * from planet_osm_polygon) as zones&lt;/Parameter&gt;
    &lt;Parameter name="type"&gt;postgis&lt;/Parameter&gt;
    &lt;Parameter name="password"&gt;password&lt;/Parameter&gt;
    &lt;!-- &lt;Parameter name="host"&gt;localhost&lt;/Parameter&gt; --&gt;
    &lt;Parameter name="user"&gt;osm&lt;/Parameter&gt;
    &lt;Parameter name="dbname"&gt;zones&lt;/Parameter&gt;
    &lt;Parameter name="estimate_extent"&gt;false&lt;/Parameter&gt;
    &lt;Parameter name="extent"&gt;-20037508,-19929239,20037508,19929239&lt;/Parameter&gt;
  &lt;/Datasource&gt;
&lt;/Layer&gt;</pre>

		<p>Кстати, этот фрагмент стиля является не самым оптимальным, но он первым пришёл мне в голову, а кроме того, он хорошо иллюстрирует возможности файла стилей.</p>

		<p>Его неоптимальность заключается в том, что во-первых, запрос извлекает из таблицы все поля, вне зависимости от того, нужны ли они для отрисовки карты или нет. В моём случае достаточно оставить поля way и name - их вполне достаточно для отрисовки контура участка и его номера.</p>

		<p>Второй момент - запрос написан не оптимально, т.к. извлекает из таблицы все строки, а Mapnik будет рисовать только те объекты, которые удовлетворяют настройкам фильтра. Вместо этого можно дополнить запрос условием WHERE name IS NOT NULL AND name &lt;&gt; '' AND area = 'yes', а из описания стиля удалить все фильтры.</p>

		<p>Третий момент - это настройка extent, в которой указаны границы всего мира, хотя, наверняка, локальные данные находятся в каких-то предсказуемых границах. Например, локальные данные в моём случае ограничиваются только Республикой Башкортостан, Республикой Татарстан и Оренбургской областью. Можно однажды выполнить следующий запрос:</p>

		<pre class="code">SELECT ST_Extent(way)
FROM (SELECT ST_ConvexHull(ST_Extent(way)) AS way
FROM planet_osm_polygon
UNION SELECT ST_ConvexHull(ST_Extent(way)) AS way
FROM planet_osm_point
UNION SELECT ST_ConvexHull(ST_Extent(way)) AS way
FROM planet_osm_line
UNION SELECT ST_ConvexHull(ST_Extent(way)) AS way
FROM planet_osm_roads) AS ways;</pre>

		<p>и прописать в настройки extent возвращённые значения. Это позволит Mapnik'у не выполнять запросы к базе данных, если заведомо известно, что запрос не вернёт результатов для интересующей его области.</p>

		<p>Более подробно о рекомендациях по оптимизации файла стилей Mapnik можно прочитать в статье <a href="https://github.com/mapnik/mapnik/wiki/OptimizeRenderingWithPostGIS">Optimize Rendering with PostGIS</a>.</p>

		<h2>2. Использование информации из базы данных</h2>

		<p>Кроме заливки информации в локальную базу данных, я также пользуюсь и основной базой данных Mapnik, непосредственно залезая в её недра с помощью SQL-запросов. Поэтому мне в её таблицах бывают нужны некоторые атрибуты объектов, которые по умолчанию не импортируются в базу данных утилитой osm2pgsql.</p>

		<p>Чтобы указать дополнительные поля, нужно отредактировать файл стиля базы данных /usr/share/osm2pgsql/default.style</p>

		<p>Например, я добавил в файл стиля базы данных колонки addr:city и addr:street, которые берутся из одноимённых атрибутов объектов из файла OSM:</p>

		<pre class="code">node,way         addr:city           text
linearnode,way   addr:street         text  linear</pre>

		<p>node означает, что этот атрибут может быть назначен точке и должен быть импортирован в таблицу planet_osm_point.</p>

		<p>way означает, что этот атрибут может быть назначен контуру (линии, дороге или многоугольнику) и должен быть импортирован в таблицу planet_osm_line, planet_osm_roads или planet_osm_polygon.</p>

		<p>Теперь информацию из базы данных можно извлекать с помощью SQL-запросов, в чём особенно помогают различные функции PostGIS.</p>

		<p>Вот лишь краткий список функций, которые оказались полезными для моих задач:</p>

		<ol>
			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_AsText.html">ST_AsText</a> - возвращает геометрический объект в формате WKT (<a href="http://en.wikipedia.org/wiki/Well-known_text">Well-known Text</a>), описанный в стандартах OpenGIS.</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_Transform.html">ST_Transform</a> - переводит координаты опорных точек геометрического объекта из одной проекции в указанную.</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_GeomFromText.html">ST_GeomFromText</a> - возвращает геометрический объект по его описанию в формате WKT и (опционально) заданной проекции.</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_IsValid.html">ST_IsValid</a> - проверяет правильность объекта - замкнутость многоугольника, отсутствие самопересечений и т.п.</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_PointOnSurface.html">ST_PointOnSurface</a> - возвращает точку, находящуюся строго на поверхности объекта (многоугольника или мультиполигона, многоугольника с дырами - геометрического объекта, имеющего один внешний контур и произвольное количество внутренних контуров).</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_ContainsProperly.html">ST_ContainsProperly</a> - функция, возвращающая "истину", если второй объект находится строго внутри первого. Достаточно, чтобы хотя-бы одна вершина второго объекта не попала внутрь первого, или попала в дыру первого объекта, чтобы функция вернула "ложь".</li>

			<li><a href="http://postgis.refractions.net/documentation/manual-1.5/ST_Extent.html">ST_Extent</a> - агрегатная функция (работает подобно агрегатным функциям COUNT, MIN, MAX, SUM или AVG), возвращает геометрический объект BOX - прямоугольник, охватывающий выбранные геометрические объекты.</li>
		</ol>

		<p>Для чего можно использовать эти функции? Приведу несколько примеров, иллюстрирующих, как их использую я.</p>

		<p>Например, для того, чтобы удалить из таблицы planet_osm_polygon многоугольники с самопересечениями и просто многоугольники, имеющие какие-то ошибки, можно воспользоваться таким запросом:</p>

		<pre class="code">DELETE FROM planet_osm_polygon
WHERE NOT ST_IsValid(way);</pre>

		<p>Или можно вернуть координаты точки на поверхности каждого дома из таблицы planet_osm_polygon в формате WKT в проекции WGS 84:</p>

		<pre class="code">SELECT ST_AsText(ST_Transform(ST_PointOnSurface(way), 4326))
FROM planet_osm_polygon
WHERE building IS NOT NULL;</pre>

		<p>Или, например, найти, контур здания по точке внутри него:</p>

		<pre class="code">SELECT way
FROM planet_osm_polygon
WHERE building IS NOT NULL
  AND ST_ContainsProperly(way, ST_Transform(ST_GeomFromText('POINT(48.2445263783448 55.8405766215408)', 4326), 900913));</pre>

		<p>Где 48.2445263783448 - долгота, 55.8405766215408 - широта.</p>

		<p>Или вычислить прямоугольник, содержащий весь населённый пункт с указанным именем:</p>

		<pre class="code">SELECT ST_Extent(ST_Transform(way, 4326))
FROM planet_osm_polygon
WHERE place IN ('city', 'town', 'village', 'hamlet')
  AND name = 'Салават';</pre>

		<p>Естественно, чтобы извлекать значения полей addr:city, addr:street, нужно их сначала добавить в файл стиля базы данных для утилиты osm2pgsql, а затем импортировать данные, что мы уже проделали в предыдущем пункте этой заметки. Правда, не всегда и везде проставляются значения этих полей, потому что для отрисовки карты Mapnik их никак не использует - поверх дома выводится только его номер.</p>

		<p>Но некоторые поля можно проставить довольно просто. Например, чтобы проставить поле "addr:city" у всех домов, попадающих в административную границу какого-либо населённого пункта, я пользуюсь скриптом на Perl, часть которого приведена ниже:</p>

		<pre class="code"># Перебираем населённые пункты, прописываем домам населённый пункт в поле addr:city
sub osm_fill_city()
{
  my $total = 0;
  my $sth_polygon = $dbh_o-&gt;prepare("UPDATE planet_osm_polygon
                                     SET \"addr:city\" = ?
                                     WHERE building IS NOT NULL
                                       AND (\"addr:city\" IS NULL OR \"addr:city\" = '')
                                       AND ST_ContainsProperly(ST_GeomFromText(?, 900913), way)");
  my $sth_point = $dbh_o-&gt;prepare("UPDATE planet_osm_point
                                   SET \"addr:city\" = ?
                                   WHERE building IS NOT NULL
                                     AND (\"addr:city\" IS NULL OR \"addr:city\" = '')
                                     AND ST_ContainsProperly(ST_GeomFromText(?, 900913), way)");
  my $sth_city = $dbh_o-&gt;prepare("SELECT name,
                                         ST_AsText(way)
                                  FROM planet_osm_polygon
                                  WHERE place IN ('city', 'town', 'village', 'hamlet')
                                     AND name IS NOT NULL
                                     AND name &lt;&gt; ''");
  $sth_city-&gt;execute();
  while (my ($name, $wkt) = $sth_city-&gt;fetchrow_array())
  {
    $sth_polygon-&gt;execute($name, $wkt);
    $sth_point-&gt;execute($name, $wkt);
    $total++;
    print "Простановка населённых пунктов на зданиях, всего обработано населённых пунктов: $total\r";
  }
  $sth_city-&gt;finish();
  $sth_point-&gt;finish();
  $sth_polygon-&gt;finish();
  print "Простановка населённых пунктов на зданиях, всего обработано населённых пунктов: $total\n";
}</pre>

		<p>Можно, конечно, не заниматься этим, а взять координаты или контур интересующего нас объекта и с помощью функции ST_ContainsProperly узнать, в административные границы какого населённого пункта этот объект попадает.</p>

		<h2>3. Геокодинг - поиск географических объектов</h2>

		<p>Эту информацию без дополнительной обработки можно использовать для обратного геокодинга, то есть для получения адреса здания по географическим координатам точки, попавшей в контур здания:</p>

		<pre class="code">SELECT "addr:city", "addr:street", "addr:housenumber"
FROM planet_osm_polygon
WHERE building IS NOT NULL
  AND building &lt;&gt; ''
  AND "addr:city" IS NOT NULL
  AND "addr:city" &lt;&gt; ''
  AND "addr:street" IS NOT NULL
  AND "addr:street" &lt;&gt; ''
  AND "addr:housenumber" IS NOT NULL
  AND "addr:housenumber" &lt;&gt; ''
  AND ST_ContainsProperly(way, ST_Transform(ST_GeomFromText('POINT(55.98886 54.74241)', 4326), 900913));</pre>

		<p>Прямой же геокодинг - нахождение координат дома по адресу - не является столь же тривиальной задачей, как обратный геокодинг. Это так, потому что людей довольно трудно заставить писать адрес всегда одним и тем же образом. Люди используют сокращения слов, переставляют слова местами, пропускают слова, кажущиеся им незначимыми, а подобные знания в "голову" компьютера не заложишь.</p>

		<p>Для себя я нашёл подходящее решение, которое в целом меня устраивает, но не является универсальным, т.к. опирается на некоторые допущения, которые верны для интересующих меня населённых пунктов.</p>

		<p>Для поиска адреса создаётся индекс адресов, в который помещаются "нормализованные" строки, содержащие название населённого пункта, улицы и дома. Перед поиском адреса по индексу, искомый адрес тоже переводится в нормализованную форму, а дальнейший поиск выполняется простым SQL-запросом.</p>

		<p>Процедура нормализации у меня делится на три части, из которых самой сложной является нормализация названия улицы.</p>

		<p>Нормализация названия населённого пункта:</p>

		<ol>
			<li>Буквы переводятся в нижний регистр,</li>

			<li>Удаляются незначащие пробельные символы - символы в начале и конце строки, а подряд идущие пробельные символы заменяются на один пробел,</li>

			<li>Буква "ё" заменяется на "е",</li>

			<li>Удаляются сокращения "г.", "п.", "с.", "д.", слова "город", "поселок", "село", "деревня".</li>
		</ol>

		<p>Полученная строка используется для сравнения.</p>

		<p>Из неучтённых особенностей тут могут быть одноимённые населённые пункты разного класса. Например, посёлок Октябрьский и город Октябрьский. Или одноимённые населённые пункты из разных районов - посёлок Фёдоровка рядом с Уфой и посёлок Фёдоровка в Фёдоровском районе. Но поскольку мне нужен поиск адресов только в 9 городах, то эти особенности я учитывать не стал.</p>

		<p>Нормализация номера дома:</p>

		<ol>
			<li>Буквы переводятся в нижний регистр,</li>

			<li>Удаляются незначащие пробельные символы - символы в начале и конце строки, а подряд идущие пробельные символы заменяются на один пробел,</li>

			<li>Буква "ё" заменяется на "е".</li>
		</ol>

		<p>Из неучтённых особенностей тут могут быть попытки вставить в поле номера дома слово "дом" или сокращение "д.", могут быть присутствовать слова "корпус", "корп.", "строение", "стр.", попытки вместо знака дроби написать слово "дробь" и т.п.</p>

		<p>Нормализация названия улицы:</p>

		<ol>
			<li>Буквы переводятся в нижний регистр,</li>

			<li>Удаляются незначащие пробельные символы - символы в начале и конце строки, а подряд идущие пробельные символы заменяются на один пробел,</li>

			<li>Буква "ё" заменяется на "е",</li>

			<li>Получившаяся строка разбивается на последовательность слов, а границами слов считаются пробелы и точки. Это сделано для того, чтобы различные сокращения и инициалы отделились от слов, с которыми они написаны слитно,</li>

			<li>Удаляются одиночные буквы,</li>

			<li>Раскрываются сокращения "ул" -&gt; "улица", "пер" -&gt; "переулок", "пр" -&gt; "проспект", "пер" -&gt; "переулок", "бул" -&gt; "бульвар", "пл" -&gt; "площадь", "шос" -&gt; "шоссе", "наб" -&gt; "набережная", "им" -&gt; "имени",</li>

			<li>От чисел отрезаются окончания, так что строки типа "60-летия", "2-й", "1-я" превращаются просто в числа,</li>

			<li>Удаляются незначащие слова типа "лет", "летия", "реки", "имени". Названия многих улиц приурочены к юбилеям каких-либо памятных событий ("50-летия Октября" или "60 лет СССР"). Набережные, естественно, часто имеют в своём названии названия рек, вдоль которых они расположены, поэтому между названием типа "набережная реки Уфы" или "набережная Уфы" нет никакой разницы. И, наконец, улицы часто называются в честь каких-то людей, поэтому нет разницы между названиями типа "проспект имени Ленина" или "проспект Ленина",</li>

			<li>Удаляются слова-классификаторы адреса типа "улица", "проспект", "площадь", "тракт", из которых запоминается только первое.</li>

			<li>Из оставшихся слов собирается нормализованный адрес, перед которым ставится слово-классификатор адреса.</li>

			<li>В получившейся строке ищутся идущие подряд пары слов типа "имя фамилия" или "титул фамилия", из которых остаётся только фамилия. Тут я делаю предположение, что в городе не бывает улиц одного класса, названных именами однофамильцев. То есть, в городе не может быть улицы Льва Толстого и улицы Алексея Толстого, но может быть улица Льва Толстого и проспект Алексея Толстого - в этом случае однофамильцы будут различаться классом улицы. И сюда же относятся различия в титулах - алгоритм нормализации не учитывает, что могут быть улицы академика Морозова и Павлика Морозова. Это преобразование помогает находить названия улиц, в случае если имя или титул человека, в честь которого названа искомая улица, не были указаны. Тут мне пришлось приложить усилия и составить список людей, именами которых названы улицы. У меня это единый список, но вообще, хорошо бы иметь отдельный список для каждого населённого пункта - так и точность и скорость нормализации будут выше. В России для этого можно использовать адресный справочник КЛАДР или пришедший ему на смену ФИАС - читайте, например <a href="http://habrahabr.ru/post/140378/">КЛАДР умер, да здравствует ФИАС?</a></li>
		</ol>

		<p>Также при поиске дома по адресу следует учитывать, что существуют угловые дома, которым часто назначаются сразу два адреса. В проекте OpenStreetMap нет единого соглашения по тому, каким образом в базе данных указывать такие адреса. Есть несколько разных подходов, которые описаны на этой странице: <a href="http://wiki.openstreetmap.org/wiki/RU:Key:addr#.D0.A3.D0.B3.D0.BB.D0.BE.D0.B2.D1.8B.D0.B5_.D0.B4.D0.BE.D0.BC.D0.B0">Key:addr. Угловые дома</a></p>

		<p>Для отображения информации на карте я использую JavaScript-библиотеку <a href="http://leaflet.cloudmade.com/">LeafLet</a>, написанную киевским программистом Владимиром Агафонкиным. Эта библиотека отстаёт по возможностям от библиотеки <a href="http://openlayers.org">OpenLayers</a>, которая используется самим проектом OpenStreetMap, но мне она понравилась компактностью и простотой использования.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Тайловый сервер - что с ним делать?">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

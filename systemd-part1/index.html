<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="hwclock,openntpd,systemd,console-setup,linux,debian,grub2,keyboard-configuration" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2013-02-17 -->
		<title>systemd. Часть 1. Установка и использование</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>systemd. Часть 1. Установка и использование</h1>

		<p>systemd - это новый демон инициализации Linux-систем, который в последующем должен прийти на смену классическому демону SysV initd. Основные задачи, которые он призван решить - это, во-первых, ускорение загрузки системы за счёт максимального увеличения количества параллельно запускающихся сервисов, во-вторых, улучшение управляемости системы за счёт использования специфических возможностей, предоставляемых ядром Linux, в-третьих, унификация общесистемных настроек и максимальное обобщение кода запуска различных сервисов. По крайней мере, такие ощущения у меня сложились после ознакомления с документацией.</p>

		<p>Хочу поблагодарить Сергея Пташника за отличный перевод документации на systemd: <a href="http://lexpr.ru/node/498">systemd для администратора</a> от автора самой системы, Леннарта Потеринга. Также хочется сказать спасибо за многочисленные примечания к документации, которые всегда оказываются к месту. Эта и последующие мои заметки существенным образом основываются именно на этой документации, а точнее, на её <a href="http://www2.kangran.su/~nnz/pub/s4a/s4a_latest.pdf">PDF-версии</a>.</p>

		<h2>1. Установка systemd</h2>

		<p>Установить systemd довольно просто. Сначала поставим пакет:</p>

		<pre class="console"># apt-get install systemd</pre>

		<p>И пропишем использование systemd в настройках ядра Linux. Для этого откроем файл с настройками загрузчика GRUB 2:</p>

		<pre class="console"># vi /etc/default/grub</pre>

		<p>И добавим в настройку GRUB_CMDLINE_LINUX_DEFAULT дополнительную опцию init=/lib/systemd/systemd. После редактирования у меня эта опция стала выглядеть следующим образом:</p>

		<pre class="code">GRUB_CMDLINE_LINUX="video=VGA-1:640x480 video=TV-1:640x480 rootfstype=ext4 init=/lib/systemd/systemd"</pre>

		<p>Теперь применим изменения, сгенерировав новый файл конфигурации загрузчика:</p>

		<pre class="console"># update-grub</pre>

		<p>Теперь можно перезагрузить систему, чтобы начать использовать systemd:</p>

		<pre class="console"># shutdown -r now</pre>

		<h2>2. Решение проблем</h2>

		<h3>2.1. Локализация текстовой консоли</h3>

		<p>Первая проблема, с которой я столкнулся - это ошибка запуска скрипта console-cyrillic. Этот скрипт должен запускаться при активной текстовой консоли, а systemd запускает все скрипты инициализации асинхронно, в результате чего этот скрипт отрабатывает к моменту, когда уже запущен X-сервер. Как следствие - в консоли вместо русских букв отображаются квадраты, нельзя переключить раскладку и переключиться обратно в графический сеанс.</p>

		<p>console-cyrillic - это устаревший пакет, который остался в моей системе с тех времён, когда я её устанавливал (а было это во времена Etch). Этот пакет имеется в новых версиях Debian и до сих пор поддерживается, однако более универсальной альтернативой для него являются пакеты console-setup и keyboard-configuration. В статье <a href="http://www.abone.pp.ru/2011/05/ubuntu-1104-natty.html">Отображение русского в консоли Ubuntu 11.04 Natty</a> описаны необходимые действия по их настройке.</p>

		<p>Установим необходимые пакеты:</p>

		<pre class="console"># apt-get install console-setup keyboard-configuration</pre>

		<p>Если по каким-то причинам конфигуратор пакетов не был запущен при установке пакетов, можно запустить конфигурирование пакетов принудительно:</p>

		<pre class="console"># dpkg-reconfigure console-setup
# dpkg-reconfigure keyboard-configuration</pre>

		<p>Вообще, в systemd предусмотрены новые файлы конфигурации для настройки текстовой консоли, но в моей системе эти настройки не сработали.</p>

		<h3>2.2. Сохранение системного времени в аппаратные часы BIOS</h3>

		<p>При смене настроек времени, по каким-то причинам, не происходит сохранение времени в часах BIOS. Сохранить текущее системное время в аппаратные часы можно с помощью команды:</p>

		<pre class="console"># hwclock -w</pre>

		<p>Реальное время, которое будет сохранено в часы BIOS, зависит от третьей строчки файла /etc/adjtime. В случае строки UTC будет сохраняться время по Гринвичу, в случае строки LOCAL - будет сохранено время текущего часового пояса.</p>

		<p>Нужно отметить, что начиная с Wheezy, настройка UTC удалена из файла /etc/default/rcS и вместо неё теперь используется настройка из файла /etc/adjtime: <a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=699297">release-notes: utc/local timezone no longer in /etc/default/rcS</a>.</p>

		<p>Корень же проблемы кроется в том, что я использую openntpd, а не ntpd. В случае работающего ntpd в ядре системы включается сохранение текущего системного времени в аппаратный таймер каждые 11 минут. Разработчики systemd посчитали, что этого достаточно. Если же ntpd не используется, то нельзя определить, какие из часов точнее - аппаратные или системные, поэтому и нет смысла предпочитать одни часы другим. В случае необходимости, пользователь должен сам настроить часы вручную необходимым образом.</p>

		<p>Для решения этой проблемы я решил написать свой service-файл для демона openntpd. Содержимое service-файла /etc/systemd/system/openntpd.service:</p>

		<pre class="code">[Unit]
Description=openntpd
After=network.target

[Service]
Type=simple
ExecStart=/usr/sbin/ntpd -dsf /etc/openntpd/ntpd.conf
ExecStartPost=/bin/chown ntpd /var/lib/openntpd/ntpd.drift
ExecStop=/sbin/hwclock -w

[Install]
WantedBy=multi-user.target</pre>

		<p>Теперь нужно остановить уже запущенный экземпляр openntpd, сообщить systemd о том, что его конфигурация изменилась:</p>

		<pre class="console"># systemctl stop openntpd.service
# systemctl daemon-reload</pre>

		<p>Включить только что созданный файл сервиса в автозагрузку и запустить openntpd:</p>

		<pre class="console"># systemctl enable openntpd.service
# systemctl start openntpd.service</pre>

		<h2>3. Управление сервисами</h2>

		<p>systemd, в отличие от inetd, умеет самостоятельно отслеживать все процессы, порождённые сервисом. Для этого используются так называемые контрольные группы процессов - cgroups. Каждый сервис запускается с собственным идентификатором группы. Все дополнительные процессы, порождаемые в рамках сервиса, так же получают этот идентификатор. Благодаря этому отпадает необходимость в использовании PID-файлов для управления сервисом. Также, благодаря контрольным группам, процессы, порождённые сервисом, никогда не теряются. Например, CGI-процесс будет остановлен вместе с веб-сервером, даже если веб-сервер не позаботится о его остановке и не поместит идентификатор процесса в PID-файл. Процессы пользователей тоже помещаются в отдельную контрольную группу, и отслеживаются подсистемой logind, пришедшей на смену ConsoleKit.</p>

		<p>Вторая важная особенность systemd заключается в том, что он обладает собственной системой журналирования, которая называется journald. Эта система агрегирует информацию из разных источников и привязывает её к сервисам. В одном месте с привязкой к сервису собираются сообщения ядра, сообщения процессов, отправленные через syslog, сообщения, отправленные с помощью собственного API journald и сообщения, отправленные процессом на стандартный вывод - STDOUT и на стандартный поток для диагностических сообщений - STDERR. Также systemd отслеживает коды завершения процессов. Благодаря этому, всю диагностическую информацию сервиса можно просматривать в одном месте и удобно диагностировать неисправности.</p>

		<ul>
			<li><b>systemctl</b> - просмотр статусов сервисов. Если вывод команды не перенаправляется куда-либо, а попадает на консоль, то для просмотра статусов сервисов автоматически запускается программа-пейджер, обычно это less,</li>

			<li><b>systemctl status <i>openntpd.service</i></b> - подробный просмотр статуса указанного сервиса (openntpd),</li>

			<li><b>systemctl status --follow <i>openntpd.service</i></b> - просмотр статуса указанного сервиса (openntpd) с выводом сообщений от сервиса в процессе их поступления. У этой опции есть более короткий аналог - -f, который в моей системе по каким-то причинам не заработал. Возможно дело в том, что опция -f имеет ещё второе значение - --force и systemctl не умеет определять, какая именно из опций имеется в виду,</li>

			<li><b>systemctl status -n10 <i>openntpd.service</i></b> - просмотр статуса указанного сервиса (openntpd) с выводом 10 последних сообщений сервиса,</li>

			<li><b>systemctl reset-failed</b> - сброс всех статусов завершения, отображаемых по команде просмотра статуса сервиса,</li>

			<li><b>systemd-cgls</b> - просмотр иерархии контрольных групп процессов (нечто подобное можно получить при помощи команды ps xawf -eo pid,user,cgroups,args),</li>

			<li><b>systemctl daemon-reload</b> - перезагрузка конфигурации systemd,</li>

			<li><b>systemctl start <i>openntpd.service</i></b> - запуск указанного сервиса (openntpd), аналогично update-rc.d <i>openntpd</i> start для SysV initd,</li>

			<li><b>systemctl stop <i>openntpd.service</i></b> - остановка указанного сервиса (openntpd), аналогично update-rc.d <i>openntpd</i> stop для SysV initd,</li>

			<li><b>systemctl restart <i>openntpd.service</i></b> - перезапуск указанного сервиса (openntpd),</li>

			<li><b>systemctl enable <i>openntpd.service</i></b> - включение запуска указанного сервиса (openntpd) при загрузке системы, аналогично update-rc.d <i>openntpd</i> enable для SysV initd,</li>

			<li><b>systemctl disable <i>openntpd.service</i></b> - отключение запуска указанного сервиса (openntpd) при загрузке системы, аналогично update-rc.d <i>openntpd</i> disable для SysV initd,</li>

			<li><b>systemctl mask <i>openntpd.service</i></b> - запрет запуска указанного сервиса (openntpd), его даже будет нельзя запустить вручную,</li>

			<li><b>systemctl unmask <i>openntpd.service</i></b> - разрешение запуска указанного сервиса (openntpd), его можно будет запустить вручную, также будет разрешён запуск при загрузке системы, если он был настроен,</li>

			<li><b>systemctl kill <i>openntpd.service</i></b> - отправка сигнала (по умолчанию отправляется сигнал SIGTERM) всем процессам в контрольной группе сервиса (openntpd),</li>

			<li><b>systemctl kill -s SIGKILL <i>openntpd.service</i></b> - отправка сигнала SIGKILL всем процессам в контрольной группе сервиса (openntpd). Можно также использовать сокращённое название сигнала - KILL,</li>

			<li><b>systemctl kill -s HUP --kill-who=main <i>crond.service</i></b> - отправка сигнала SIGHUP главному процессу контрольной группы сервиса (crond). Этот пример заставит crond перечитать файл конфигурации, при этом задания, запущенные crond этот сигнал не получат и продолжат нормальную работу,</li>

			<li><i><b>systemctl help <i>openntpd.service</i></b></i> - просмотр документации сервиса (не работает в Debian Wheezy),</li>

			<li><b>systemd-analyze blame</b> - вывод списка сервисов, отсортированного по убыванию времени, потраченного на их запуск. Команда может быть полезной для поиска узких мест в процессе инициализации системы,</li>

			<li><b>systemd-analyze plot &gt; plot.svg</b> - вывод временнОй диаграммы в формате SVG, иллюстрирующей последовательность (и параллельность) запуска сервисов.</li>
		</ul>

		<h2>4. Новые файлы конфигурации системы</h2>

		<p>systemd вводит ряд новых файлов конфигурации для общесистемных настроек. Предполагается, что эти файлы со временем станут стандартными и вытеснят файлы конфигурации системы, специфичные для разных дистрибутивов. Пока же этого не произошло, systemd будет использовать файлы конфигурации дистрибутивов, если новые файлы отсутствуют.</p>

		<p>Кроме того, поскольку теперь все сервисы будут запускаться с помощью service-файлов, отпадает необходимость в использовании файлов, включаемых в shell-скрипты. Это файлы, располагающиеся в каталогах /etc/default (семейство Debian) и /etc/sysconfig (семейство RedHat). Поскольку в service-файлах ориентироваться намного проще, чем в shell-скриптах, нет необходимости выносить настройки сервисов в отдельные файлы - все необходимые настройки можно вписать прямо в service-файл.</p>

		<p>Перечислим новые файлы конфигурации, вводимые systemd:</p>

		<ul>
			<li><b>/etc/hostname</b> - сетевое имя системы,</li>

			<li><b>/etc/vconsole.conf</b> - настройки шрифта системной консоли и раскладки клавиатуры,</li>

			<li><b>/etc/locale.conf</b> - языковые настройки системы,</li>

			<li><b>/etc/modules-load.d/*.conf</b> - каталог для перечисления модулей ядра, которые нужно принудительно загрузить при загрузке системы,</li>

			<li><b>/etc/sysctl.d/*.conf</b> - каталог для настроек параметров ядра, дополняет классический файл /etc/sysctl.conf,</li>

			<li><b>/etc/tmpfiles.d/*.conf</b> - каталог для управления настройками временных файлов,</li>

			<li><b>/etc/binfmt.d/*.conf</b> - каталог для регистрации форматов исполняемых файлов, например форматов Java, Mono, WINE,</li>

			<li><b>/etc/os-release</b> - файл с идентификатором дистрибутива и его версии,</li>

			<li><b>/etc/machie-id</b> - файл с постоянным уникальным идентификатором системы,</li>

			<li><b>/etc/machie-info</b> - файл с описательным сетевым именем системы. Здесь же настраивается значок системы, который будет отображаться в графических оболочках. Файл обслуживается демоном systemd-hostnamed.</li>
		</ul>

		<h2>5. Подсистема журналирования journald</h2>

		<p>Как уже было сказано, systemd вводит новую систему журналирования, которая собирает информацию из разных источников (сообщения ядра, сообщения, отправленные в syslog, на стандартный вывод STDOUT и на стандартный поток диагностических сообщений STDERR) в одном месте. Эта система не заставляет отказываться от стандартного демона журналирования syslog - можно пользоваться обеими системами журналирования параллельно.</p>

		<p>journald использует для хранения журнальной информации два каталога:</p>

		<ol>
			<li><b>/run/log/journal</b> - каталог с кольцевым буфером последних сообщений,</li>

			<li><b>/var/log/journal</b> - каталог с постоянным хранением всех сообщений.</li>
		</ol>

		<p>По умолчанию используется только первый каталог, а для включения постоянного хранения всех сообщений второй каталог нужно создать вручную (в Debian Wheezy этот каталог создаётся автоматически, при установке systemd, а первый каталог не используется):</p>

		<pre class="console"># mkdir -p /var/log/journald</pre>

		<p>После этого можно, но совершенно не обязательно, удалить стандартный демон журналирования rsyslog или ng-syslog.</p>

		<p>Настройки демона journald в Debian Wheezy хранятся в файле <b>/etc/systemd/systemd-journald.conf</b>. В частности, там можно задать настройки сжатия файла журнала, задать лимит размера файлов журнала, настроить дублирование сообщений в системную консоль или в демон syslog.</p>

		<p>Пользователь root и пользователи из группы adm имеют доступ ко всем сообщениям в журнале, а обычные пользователи - только к сообщениям, сгенерированным их процессами.</p>

		<p>Для просмотра сообщений из журнала в Debian Wheezy можно воспользоваться командой systemd-journalctl (в руководстве указана команда journalctl):</p>

		<ul>
			<li><b>systemd-journalctl</b> - просмотр всех сообщений. Как и в случае systemctl, если вывод команды никуда не перенаправляется, а попадает на консоль, для более удобного просмотра сообщений автоматически запускается программа-пейджер, обычно less,</li>

			<li><b>systemd-journalctl -f</b> - просмотр сообщений в процессе их поступления,</li>

			<li><b>systemd-journalctl -n10</b> - просмотр 10 последних сообщений,</li>

			<li><i><b>systemd-journalctl -b</b></i> - просмотр сообщений, сгенерированных с момента загрузки системы (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl -b -p err</b></i> - просмотр сообщений, сгенерированных с момента загрузки системы и имеющих приоритет error или выше (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl --since=yesterday</b></i> - просмотр всех сообщений, сгенерированных со вчерашнего дня (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl --since=2012-10-15 --until="2012-10-16 23:59:59"</b></i> - просмотр всех сообщений, сгенерированных 15 и 16 октября 2012 года (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl -u httpd --since=00:00 --until=09:30</b></i> - просмотр всех сообщений, сгенерированных пользователем httpd сегодня с полуночи до полдесятого (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl /dev/sdc</b></i> - просмотр всех сообщений, упоминающих диск sdc (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl /usr/sbin/vpnc</b></i> - просмотр всех сообщений от процессов /usr/sbin/vpnc (не работает в Debian Wheezy),</li>

			<li><i><b>systemd-journalctl /usr/sbin/vpnc /usr/sbin/dhclient</b></i> - просмотр всех сообщений от процессов /usr/sbin/vpnc и /usr/sbin/dhclient, объединённый и отсортированный по времени (не работает в Debian Wheezy),</li>
		</ul>

		<p>Кроме простого просмотра текстовых сообщений имеется возможность просматривать метаданные, которые journald самостоятельно добавляет к каждой записи в журнале. Чтобы увидеть эти поля, достаточно воспользоваться следующей опцией, переключающей формат вывода данных:</p>

		<ul>
			<li><b>systemd-journalctl -o verbose</b> - выводит вместе с сообщением из журнала все сопутствующие сообщению метаданные в удобном для восприятия человеком виде. Другие доступные форматы: export - тот же самый формат verbose, но без отступов, json - вывод в формате JSON, cat - вывод только текста сообщений без каких-либо дополнительных данных.</li>
		</ul>

		<p>Названия полей, начинающиеся со знака подчёркивания, можно использовать для фильтрации сообщений. Журнал индексируется по всем полям, поэтому поиск выполняется быстро. Примеры фильтрации сообщений по метаданным:</p>

		<ul>
			<li><b>systemd-journalctl _UID=70</b> - вывод всех сообщений от процессов пользователя с идентификатором 70,</li>

			<li><b>systemd-journalctl _UID=70 _UID=71</b> - вывод всех сообщений от процессов пользователей с идентификаторами 70 и 71. Указание одноимённых полей автоматически подразумевает операцию логического ИЛИ,</li>

			<li><b>systemd-journalctl _HOSTNAME=epsilon _COMM=avahi-daemon</b> - вывод всех сообщений от процессов с именем avahi-daemon, работающих на компьютере с именем epsilon. В данном случае указаны разные поля, поэтому подразумевается операция логического И,</li>

			<li><b>systemd-journalctl _HOSTNAME=theta _UID=70 + _HOSTNAME=epsilon _COMM=avahi-daemon</b> - вывод сообщений, соответствующих любому из двух фильтров, объединённых знаком +. Знак + указывает явную операцию логического ИЛИ, которая имеет более низкий приоритет, чем И,</li>

			<li><i><b>systemd-journalctl -F _SYSTEMD_UNIT</b></i> - вывод всех значений поля _SYSTEMD_UNIT, имеющихся в журнале. Полученные значения можно использовать для фильтрации интересующих записей (не работает в Debian Wheezy).</li>
		</ul>

		<h2>6. Ссылки:</h2>

		<ol>
			<li><a href="http://wiki.debian.org/systemd">systemd</a> - о systemd в Debian</li>

			<li><a href="http://tux-the-penguin.blogspot.ru/2010/09/systemd.html">Система инициализации Systemd. Часть I</a></li>

			<li><a href="http://tux-the-penguin.blogspot.ru/2010/09/systemd-ii.html">Система инициализации Systemd. Часть II</a></li>

			<li><a href="http://lexpr.ru/node/498">systemd для администратора</a> - русский перевод документации от автора systemd, Леннарта Потеринга</li>

			<li><a href="http://www2.kangran.su/~nnz/pub/s4a/s4a_latest.pdf">systemd для администратора</a> - предыдущий перевод в формате PDF</li>

			<li><a href="http://www.abone.pp.ru/2011/05/ubuntu-1104-natty.html">Отображение русского в консоли Ubuntu 11.04 Natty</a></li>

			<li><a href="http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=699297">release-notes: utc/local timezone no longer in /etc/default/rcS</a></li>

			<li><a href="http://lists.freedesktop.org/archives/systemd-devel/2011-May/002526.html">[systemd-devel] [ANNOUNCE] systemd v28</a></li>
		</ol>

		<p><a href="mailto:vladimir@stupin.su?subject=systemd. Часть 1. Установка и использование">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

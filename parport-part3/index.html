<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="lp,linux,parport,перевод,ppdev,параллельный порт" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2019-04-28 -->
		<title>Тим Во. Подсистема параллельного порта Linux 2.4 - часть 3, parport - справочник программного интерфейса драйвера параллельного порта Linux, 2000</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Тим Во. Подсистема параллельного порта Linux 2.4 - часть 3, parport - справочник программного интерфейса драйвера параллельного порта Linux, 2000</h1>

		<p>Перевод статьи: <a href="https://people.redhat.com/twaugh/parport/html/parportguide.html">The Linux 2.4 Parallel Port Subsystem</a></p>

		<p>Автор: Тим Во (Tim Waugh)</p>

		<p>Предыдущая часть: <a href="../parport-part2/">Подсистема параллельного порта Linux 2.4 - часть 2, ppdev - драйверы устройств, работающие в пространстве пользователя</a></p>

		<h2>1. Справочник программного интерфейса драйвера параллельного порта Linux</h2>

		<h3>1.1. parport_device_num</h3>

		<h4>1.1.1. Название</h4>

		<p>parport_device_num -- преобразовать координаты устройства</p>

		<h4>1.1.2. Обзор</h4>

		<pre class="code">int parport_device_num(int parport, int mux, int daisy);</pre>

		<h4>1.1.3. Аргументы</h4>

		<dt>parport</dt><dd>номер параллельного порта</dd>

		<dt>mux</dt><dd>номер порта мультиплексора (-1, если мультиплексора нет)</dd>

		<dt>daisy</dt><dd>адрес в цепочке устройств (-1, если нет адреса в цепочке)</dd>

		<h4>1.1.4. Описание</h4>

		<p>Пытается найти устройство на указанном параллельном порту, порту мультиплексора и адресе в цепочке, и возвращает номер устройства или -NXIO, если устройство с такими координатами не существует.</p>

		<hr />

		<h3>1.2. parport_device_coords</h3>

		<h4>1.2.1. Название</h4>

		<p>parport_device_coords -- преобразовать канонический номера устройства</p>

		<h4>1.2.2. Обзор</h4>

		<pre class="code">int parport_device_coords(int devnum, int * parport, int * mux, int * daisy);</pre>

		<h4>1.2.3. Аргументы</h4>

		<dt>devnum</dt><dd>номер устройства</dd>

		<dt>parport</dt><dd>указатель на область для сохранения номера параллельного порта</dd>

		<dt>mux</dt><dd>указатель на область для сохранения номера порта мультиплексора</dd>

		<dt>daisy</dt><dd>указатель на область для сохранения адреса в цепочке устройств</dd>

		<h4>1.2.4. Описание</h4>

		<p>Функция преобразует номер устройства в его координаты: к какому параллельному порту в системе оно подключено, к какому порту мультиплексора оно подключен, если на этом порту имеется мультиплексор, и какой адрес имеет в цепочке устройств, если оно находится в цепочке устройств.</p>

		<p>Вызывающая сторона должна выделить области для сохранения parport, mux и daisy.</p>

		<p>Если устройство с указанным номером отсутствует, то возвращается -ENXIO. В противном случае области, на которые указывают parport, mux и daisy, заполняются координатами устройства. Если координата не определена, то используется значение -1.</p>

		<p>На самом деле функция не очень полезна, но этот интерфейс был предложен в IEEE 1284.3.</p>

		<hr />

		<h3>1.3. parport_find_device</h3>

		<h4>1.3.1. Название</h4>

		<p>parport_find_device -- найти указанное устройство</p>

		<h4>1.3.2. Обзор</h4>

		<pre class="code">int parport_find_device(const char * mfg, const char * mdl, int from);</pre>

		<h4>1.3.3. Аргументы</h4>

		<dt>mfg</dt><dd>строка, содержащая название требуемого производителя</dd>

		<dt>mdl</dt><dd>строка, содержащая название требуемой модели устройства</dd>

		<dt>from</dt><dd>номер предыдущего устройства, найденного в процессе поиска, или NULL, если это новый поиск</dd>

		<h4>1.3.4. Описание</h4>

		<p>Проходит по списку устройств на параллельных портах в поисках устройства, у которого строки 'MFG' и 'MDL' в идентификаторе устройства IEEE 1284 будут совпадать с mfg и mdl.</p>

		<p>Если найдено устройство, соответствующее указанным требованиям, то возвращается номер этого устройства. Если подходящего устройства не найдено, то возвращается отрицательное значение.</p>

		<p>Новый поиск начинается с передачи значения NULL в аргументе from. Если from - не NULL, то поиск продолжается с указанного устройства.</p>

		<hr />

		<h3>1.4. parport_find_class</h3>

		<h4>1.4.1. Название</h4>

		<p>parport_find_class -- найти устройство в указанном классе</p>

		<h4>1.4.2. Обзор</h4>

		<pre class="code">int parport_find_class(parport_device_class cls, int from);</pre>

		<h4>1.4.3. Аргументы</h4>

		<dt>cls</dt><dd>требуемый класс</dd>

		<dt>from</dt><dd>номер устройства, найденного во время предыдущего поиска, или NULL, если это новый поиск</dd>

		<h4>1.4.4. Описание</h4>

		<p>Проходит по списку устройств на параллельных портах в поисках устройства, у которого строка 'CLS' в идентификаторе устройства IEEE 1284 совпадает с cls.</p>

		<p>Если найдено устройство, соответствующее указанным требованиям, то возвращается номер этого устройства. Если подходящего устройства не найдено, то возвращается отрицательное значение.</p>

		<p>Новый поиск начинается с передачи значения NULL в аргументе from. Если from - не NULL, то поиск продолжается с указанного устройства.</p>

		<hr />

		<h3>1.5. parport_register_driver</h3>

		<h4>1.5.1. Название</h4>

		<p>parport_register_driver -- зарегистрировать драйвер устройства на параллельном порту</p>

		<h4>1.5.2. Обзор</h4>

		<pre class="code">int parport_register_driver(struct parport_driver * drv);</pre>

		<h4>1.5.3. Аргументы</h4>

		<dt>drv</dt><dd>структура, описывающая драйвер</dd>

		<h4>1.5.4. Описание</h4>

		<p>Может вызываться драйвером устройства на параллельном порту для приёма уведомлений о портах, обнаруженных в системе, а также о более не доступных портах.</p>
		
		<p>Место для хранения структуры drv выделяется вызывающей стороной и не должно освобождаться вплоть до вызова parport_unregister_driver.</p>

		<p>Функция attach драйвера может блокироваться. Порт, который передан в attach, действителен только на время вызова, но если драйверу нужно взять копию указателя, то он может воспользоваться parport_get_port. Вызов parport_register_device с этим портом сделает это автоматически.</p>

		<p>Функция detach драйвера не может блокироваться. Порт, который передан в detach, действителен только на время вызова, но если драйверу нужно взять копию указателя, то для этого он должен воспользоваться parport_get_port.</p>

		<p>В случае успеха возвращает 0. В настоящее время всегда завершается успешно.</p>

		<hr />

		<h3>1.6. parport_unregister_driver</h3>

		<h4>1.6.1. Название</h4>

		<p>parport_unregister_driver -- отменить регистрацию драйвера устройства на параллельном порту</p>

		<h4>1.6.2. Обзор</h4>

		<pre class="code">void parport_unregister_driver(struct parport_driver * arg);</pre>

		<h4>1.6.3. Аргументы</h4>

		<dt>arg</dt><dd>структура, описывающая драйвер, которая была передана в parport_register_driver</dd>

		<h4>1.6.4. Описание</h4>

		<p>Должна вызываться при выгрузке драйвера устройства на параллельном порту, который зарегистрировался при помощи parport_register_driver.</p>

		<p>После возврата подпрограмма attach драйвера больше не будет вызываться, а для каждого из портов, для которого был вызван attach, будет вызвана подпрограмма detach.</p>

		<p>Если функция attach вызывающего может блокироваться, то драйвер сам должен дождаться её завершения перед выгрузкой.</p>

		<p>Перед возвратом из этой функции все вызовы detach драйвера будут гарантированно завершены.</p>

		<p>В вызове detach драйвера не разрешается блокироваться.</p>

		<hr />

		<h3>1.7. parport_get_port</h3>

		<h4>1.7.1. Название</h4>

		<p>parport_get_port -- увеличить счётчик ссылок на порт</p>

		<h4>1.7.2. Обзор</h4>

		<pre class="code">struct parport * parport_get_port(struct parport * port);</pre>

		<h4>1.7.3. Аргументы</h4>

		<dt>port</dt><dd>порт</dd>

		<h4>1.7.4. Описание</h4>

		<p>Позволяет убедиться, что указатель на структуру parport останется доступным вплоть до соответствующего вызова parport_put_port.</p>

		<hr />

		<h3>1.8. parport_put_port</h3>

		<h4>1.8.1. Название</h4>

		<p>parport_put_port -- уменьшить счётчик ссылок на порт</p>

		<h4>1.8.2. Обзор</h4>

		<pre class="code">void parport_put_port(struct parport * port);</pre>

		<h4>1.8.3. Аргументы</h4>

		<dt>port</dt><dd>порт</dd>

		<h4>1.8.4. Описание</h4>

		<p>Должна вызываться для каждого из вызовов parport_get_port, когда порт больше не требуется.</p>

		<hr />

		<h3>1.9. parport_find_number</h3>

		<h4>1.9.1. Название</h4>

		<p>parport_find_number -- найти параллельный порт по номеру</p>

		<h4>1.9.2. Обзор</h4>

		<pre class="code">struct parport * parport_find_number(int number);</pre>

		<h4>1.9.3. Аргументы</h4>

		<dt>number</dt><dd>номер параллельного порта</dd>

		<h4>1.9.4. Описание</h4>

		<p>Возвращает параллельный порт с указанным номером или NULL, если его нет.</p>

		<p>Выполняет неявный вызов parport_get_port. Чтобы отбросить ссылку на порт, которая была получена через parport_find_number, воспользуйтесь parport_put_port.</p>

		<hr />

		<h3>1.10. parport_find_base</h3>

		<h4>1.10.1. Название</h4>

		<p>parport_find_base -- найти параллельный порт по базовому адресу</p>

		<h4>1.10.2. Обзор</h4>

		<pre class="code">struct parport * parport_find_base(unsigned long base);</pre>

		<h4>1.10.3. Аргументы</h4>

		<dt>base</dt><dd>базовый адрес ввода-вывода</dd>

		<h4>1.10.4. Описание</h4>

		<p>Возвращает параллельный порт с указанным базовым адресом или NULL, если его нет.</p>

		<p>Выполняет неявный вызов parport_get_port. Чтобы отбросить ссылку на порт, которая была получена через parport_find_base, воспользуйтесь parport_put_port.</p>

		<hr />

		<h3>1.11. parport_register_device</h3>

		<h4>1.11.1. Название</h4>

		<p>parport_register_device -- зарегистрировать устройство на параллельном порту</p>

		<h4>1.11.2. Обзор</h4>

		<pre class="code">struct pardevice * parport_register_device(struct parport * port, const char * name, int (*pf) (void *), void (*kf) (void *), void (*irq_func) (int, void *, struct pt_regs *), int flags, void * handle);</pre>

		<h4>1.11.3. Аргументы</h4>

		<dt>port</dt><dd>порт, к которому присоединено устройство</dd>

		<dt>name</dt><dd>имя для обращения к устройству</dd>

		<dt>pf</dt><dd>обработчик вежливой просьбы освободить порт</dd>

		<dt>kf</dt><dd>обработчик сообщения о свободном порте</dd>

		<dt>irq_func</dt><dd>обработчик прерывания</dd>

		<dt>flags</dt><dd>флаги регистрации</dd>

		<dt>handle</dt><dd>данные для функций-обработчиков</dd>

		<h4>1.11.4. Описание</h4>

		<p>Функция, вызываемая драйверами устройств на параллельном порту, объявляет, что это устройство подключено к порту и сообщает системе всё, что ей нужно знать.</p>

		<p>Область для хранения name выделяется вызывающей стороной и не должна освобождаться вплоть до того, как вызывающая сторона не вызовет parport_unregister_device для этого устройства.</p>

		<p>pf - обработчик вежливой просьбы освободить порт. Выполняется, когда драйвер владеет доступом к порту, но к этому порту хочет получить доступ драйвер другого устройства. Если драйвер желает освободить порт, то он должен вернуть ноль и тогда порт будет им освобождён. Если драйвер желает сохранить доступ к порту, он должен вернуть ненулевое значение и никаких действий не будет выполнено. Вежливый драйвер постарается отпустить порт как можно раньше, при первой возможности после вежливой просьбы, после того как первая вежливая просьба была отклонена. Отметим, что если вежливый обработчик будет рад выполнить просьбу, то освобождать порт не требуется - это будет выполнено автоматически. Эта функция не может блокироваться, поскольку она может быть вызвана из контекста прерывания. Если драйвер устройства не поддерживает обработку вежливых просьб, pf может принимать значение NULL.</p>

		<p>kf - обработчик сообщения о свободном порте. Выполняется, когда порт можно затребовать в исключительный доступ. Если драйвер хочет затребовать доступ к порту, то вызов parport_claim гарантированно завершится удачно внутри обработчика сообщения о свободном порте. Если драйвер хочет затребовать доступ к порту, он должен сделать это. В противном случае никаких действий предпринимать не требуется. Эта функция не может блокироваться, поскольку она может быть вызвана из контекста прерывания. Если драйвер устройства не желает получать явные приглашения затребовать порт таким образом, kf может принимать значение NULL.</p>

		<p>irq_func - обработчик прерывания. Он вызывается, когда происходит прерывание от параллельного порта. Отметим, что если драйвер устройства желает использовать прерывания, он должен использовать parport_enable_irq, а также может отметить поле irq в структуре parport, содержащей информацию о порте.</p>

		<p>Низкоуровневый драйвер параллельного порта - один из тех, кто вызывается из request_irq и чей обработчик прерывания выполняется первым. Этот обработчик делает всё необходимое, чтобы оборудование получило подтверждение прерывания (для портов типа PC ничего специального не делается). Затем он сообщает о прерывании коду IEEE 1284, который реагирует на событие IEEE 1284 в соответствии с текущей фазой IEEE 1284. И только после этого, он вызовет irq_func. Не стоит говорить, что irq_func будет вызываться из контекста прерывания и не может блокироваться.</p>

		<p>Флаг PARPORT_DEV_EXCL предотвращает совместное использование порта и поэтому должен использоваться только в тех случаях, если совместное использование порта с другими устройствами не возможно и может привести к некорректному поведению. Старайтесь избегать! Обычно параметр flags равен нулю.</p>

		<p>Функция возвращает указатель на структуру, представляющую устройство на порту, или NULL, если не хватило памяти, чтобы выделить место для этой структуры.</p>

		<hr />

		<h3>1.12. parport_unregister_device</h3>

		<h4>1.12.1. Название</h4>

		<p>parport_unregister_device -- отменить регистрацию устройства на параллельном порту</p>

		<h4>1.12.2. Обзор</h4>

		<p>void parport_unregister_device(struct pardevice * dev);</p>

		<h4>1.12.3. Аргументы</h4>

		<dt>dev</dt><dd>указатель на структуру, представляющую устройство</dd>

		<h4>1.12.4. Описание</h4>

		<p>Отменяет действие parport_register_device.</p>

		<hr />

		<h3>1.13. parport_open</h3>

		<h4>1.13.1. Название</h4>

		<p>parport_open -- найти устройство по каноническому номеру устройства</p>

		<h4>1.13.2. Обзор</h4>

		<pre class="code">struct pardevice * parport_open(int devnum, const char * name, int (*pf) (void *), void (*kf) (void *), void (*irqf) (int, void *, struct pt_regs *), int flags, void * handle);</pre>

		<h4>1.13.3. Аргументы</h4>

		<dt>devnum</dt><dd>канонический номер устройства</dd>

		<dt>name</dt><dd>имя для обращения к устройству</dd>

		<dt>pf</dt><dd>обработчик вежливой просьбы освободить порт</dd>

		<dt>kf</dt><dd>обработчик сообщения о свободном порте</dd>

		<dt>irqf</dt><dd>обработчик прерываний</dd>

		<dt>flags</dt><dd>флаги регистрации</dd>

		<dt>handle</dt><dd>данные драйвера</dd>

		<h4>1.13.4. Описание</h4>

		<p>Функция аналогична parport_register_device, за исключением того, что находит устройство по его номеру, а не по порту, к которому оно подключено. См. parport_find_device и parport_find_class.</p>

		<p>Все параметры, за исключением devnum, такие же как и у parport_register_device. Возвращаемое значение такое же, как и у parport_register_device.</p>
		
		<hr />

		<h3>1.14. parport_close</h3>

		<h4>1.14.1. Название</h4>

		<p>parport_close -- закрыть устройство, открытое при помощи parport_open</p>

		<h4>1.14.2. Обзор</h4>

		<pre class="code">void parport_close(struct pardevice * dev);</pre>

		<h4>1.14.3. Аргументы</h4>

		<dt>dev</dt><dd>закрываемое устройство</dd>

		<h4>1.14.4. Описание</h4>

		<p>То же самое по отношению к parport_open, как parport_unregister_device по отношению к parport_register_device.</p>

		<hr />

		<h3>1.15. parport_claim</h3>

		<h4>1.15.1. Название</h4>

		<p>parport_claim -- затребовать доступ к устройству на параллельном порту</p>

		<h4>1.15.2. Обзор</h4>

		<pre class="code">int parport_claim(struct pardevice * dev);</pre>

		<h4>1.15.3. Аргументы</h4>

		<dt>dev</dt><dd>указатель на структуру данных, представляющую устройство на порту</dd>

		<h4>1.15.4. Описание</h4>

		<p>Эта функция не блокируется и поэтому может использоваться в контексте прерывания. Если parport_claim получила доступ к порту, то она вернёт ноль и порт будет доступен для использования. Она также может завершиться неудачно (вернув ненулевое значение), если порт используется другим драйвером и этот драйвер не хочет отказываться от управления портом.</p>

		<hr />

		<h3>1.16. parport_claim_or_block</h3>

		<h4>1.16.1. Название</h4>

		<p>parport_claim_or_block -- затребовать доступ к устройству на параллельном порту</p>

		<h4>1.16.2. Обзор</h4>

		<pre class="code">int parport_claim_or_block(struct pardevice * dev);</pre>

		<h4>1.16.3. Аргументы</h4>

		<dt>dev</dt><dd>указатель на структуру, представляющую устройство на порту</dd>

		<h4>1.16.4. Описание</h4>

		<p>Ведёт себя как parport_claim, но заблокируется, если необходимо подождать, когда освободится порт. Возвращаемое значение 1 указывает, что функция спала, а 0 означает, что функция сразу выполнилась успешно. Отрицательный код ошибки свидетельствует о неудаче.</p>

		<hr />

		<h3>1.17. parport_release</h3>

		<h4>1.17.1. Название</h4>

		<p>parport_release -- отказаться от доступа к устройству на параллельном порту</p>

		<h4>1.17.2. Обзор</h4>

		<pre class="code">void parport_release(struct pardevice * dev);</pre>

		<h4>1.17.3. Аргументы</h4>

		<dt>dev</dt><dd>указатель на структуру, представляющую устройство на параллельном порту</dd>

		<h4>1.17.4. Описание</h4>

		<p>Функция не может завершиться неудачно, но она не должна вызываться для порта, доступ к которому не был получен ранее. Аналогично, если доступ к порту уже был получен, не нужно пытаться получить его снова.</p>

		<hr />

		<h3>1.18. parport_yield</h3>

		<h4>1.18.1. Название</h4>

		<p>parport_yield -- уступить доступ к параллельному порту</p>

		<h4>1.18.2. Обзор</h4>

		<pre class="code">int parport_yield(struct pardevice * dev);</pre>

		<h4>1.18.3. Аргументы</h4>

		<dt>dev</dt><dd>устройство на параллельном порту</dd>

		<h4>1.18.4. Описание</h4>

		<p>Функция временно отказывается от порта, если он может быть полезен для работы других драйверов. Затем функция пытается вернуть доступ к порту при помощи parport_claim и возвращает такое же значение, как и parport_claim. Если функция завершится неудачно, то доступ к порту будет потерян и сам драйвер будет отвечать за его повторное получение.</p>

		<p>Функции parport_yield и parport_yield_blocking предназначены для отметки мест в драйвере, где другие драйверы могут затребовать доступ к порту и использовать его для связи со своими устройствами. Уступка порта аналогична его освобождению и повторному затребованию, но более эффективна, т.к. если нет других драйверов, которым требуется доступ к порту, то никаких действий не предпринимается. На деле ничего не делается даже тогда, когда есть другие устройства, ожидающие доступа, но текущее устройство находится внутри своего кванта времени. По умолчанию квант времени - полсекунды, но эта длительность может настраиваться через интерфейс /proc.</p>

		<hr />

		<h3>1.19. parport_yield_blocking</h3>

		<h4>1.19.1. Название</h4>

		<p>parport_yield_blocking -- уступить доступ к параллельному порту</p>

		<h4>1.19.2. Обзор</h4>

		<pre class="code">int parport_yield_blocking(struct pardevice * dev);</pre>

		<h4>1.19.3. Аргументы</h4>

		<dt>dev</dt><dd>устройство на параллельном порту</dd>

		<h4>1.19.4. Описание</h4>

		<p>Функция временно отказывается от порта, если он может быть полезен для работы других драйверов. Затем функция пытается вернуть доступ к порту при помощи parport_claim_or_block и возвращает такое же значение, как и parport_claim_or_block.</p>

		<hr />

		<h3>1.20. parport_negotiate</h3>

		<h4>1.20.1. Название</h4>

		<p>parport_negotiate -- согласовать режим IEEE 1284</p>

		<h4>1.20.2. Обзор</h4>

		<pre class="code">int parport_negotiate(struct parport * port, int mode);</pre>

		<h4>1.20.3. Аргументы</h4>

		<dt>port</dt><dd>используемый порт</dd>

		<dt>mode</dt><dd>согласуемый режим</dd>

		<h4>1.20.4. Описание</h4>

		<p>Используйте для согласования определённого режима передачи IEEE 1284. Параметр mode должен быть одной из констант, определённых в файле parport.h, имя которой начинается с IEEE1284_MODE_xxx.</p>

		<p>Возвращает значение 0, если периферийное устройство согласовало указанный режим. -1 возвращается, если периферийное устройство не совместимо со стандартом IEEE 1284 (или отсутствует). 1 возвращается, если периферийное устройство не согласовало указанный режим.</p>

		<hr />

		<h3>1.21. parport_write</h3>

		<h4>1.21.1. Название</h4>

		<p>parport_write -- записать блок данных в параллельный порт</p>

		<h4>1.21.2. Обзор</h4>

		<pre class="code">ssize_t parport_write(struct parport * port, const void * buffer, size_t len);</pre>

		<h4>1.21.3. Аргументы</h4>

		<dt>port</dt><dd>порт для записи</dd>

		<dt>buffer</dt><dd>буфер данных (в пространстве ядра)</dd>

		<dt>len</dt><dd>количество передаваемых байт данных</dd>

		<h4>1.21.4. Описание</h4>

		<p>Пишет до len байт из буфера в указанный порт, используя последний из согласованных (при помощи parport_negotiate) режимов передачи IEEE 1284, если этот режим поддерживает прямую передачу (от компьютера к периферийному устройству).</p>

		<p>За действительность первых len байт буфера отвечает вызывающая сторона.</p>

		<p>Функция возвращает количество переданных байт (если передано ноль или больше), а в противном случае возвращает код ошибки.</p>

		<hr />

		<h3>1.22. parport_read</h3>

		<h4>1.22.1. Название</h4>

		<p>parport_read -- прочитать блок данных из параллельного порта</p>

		<h4>1.22.2. Обзор</h4>

		<pre class="code">ssize_t parport_read(struct parport * port, void * buffer, size_t len);</pre>

		<h4>1.22.3. Аргументы</h4>

		<dt>port</dt><dd>порт для чтения</dd>

		<dt>buffer</dt><dd>буфер данных (в пространстве ядра)</dd>

		<dt>len</dt><dd>количество принимаемых байт данных</dd>

		<h4>1.22.4. Описание</h4>

		<p>Читает до len байт данных из указанного порта в буфер, используя последний из согласованных (при помощи parport_negotiate) режимов передачи IEEE 1284, если этот режим поддерживает обратную передачу (от периферийного устройства на компьютер).</p>

		<p>За доступность для записи первых len байт буфера отвечает вызывающая сторона.</p>

		<p>Функция возвращает количество принятых байт (если принято ноль или больше), а в противном случае возвращает код ошибки.</p>

		<hr />

		<h3>1.23. parport_set_timeout</h3>

		<h4>1.23.1. Название</h4>

		<p>parport_set_timeout -- задать таймаут бездействия устройства</p>

		<h4>1.23.2. Обзор</h4>

		<pre class="code">long parport_set_timeout(struct pardevice * dev, long inactivity);</pre>

		<h4>1.23.3. Аргументы</h4>

		<dt>dev</dt><dd>устройство на порту</dd>

		<dt>inactivity</dt><dd>время бездействия (в тактах)</dd>

		<h4>1.23.4. Описание</h4>

		<p>Задаёт таймаут бездействия указанного устройства на порту. Действует на функции, подобные parport_wait_peripheral. Специальное значение 0 означает - не использовать расписание при работе с этим устройством.</p>

		<p>Возвращает предыдущее значение таймаута бездействия.</p>

		<p>Все обратившиеся к parport_wait_event для этого устройства будут разбужены.</p>

		<h2>2. Подсистема параллельного порта Linux 2.2</h2>

		<p>Хотя описанный в этом документе интерфейс был значительно обновлён в ядре 2.4, в ядре 2.2 используется аналогичный механизм совместного доступа. В 2.2 доступны следующие функции:</p>

		<ul>
			<li>parport_register_device</li>

			<li>parport_unregister_device</li>

			<li>parport_claim</li>

			<li>parport_claim_or_block</li>

			<li>parport_release</li>

			<li>parport_yield</li>

			<li>parport_yield_blocking</li>
		</ul>

		<p>А также поддерживается согласование полубайтового режима:</p>

		<pre class="code">int parport_ieee1284_nibble_mode_ok(struct parport *port, unsigned char mode);</pre>

		<p>Единственными действующими значениями mode являются 0 (для полубайтового режима) и 4 (для чтения идентификатора устройства в полубайтовом режиме).</p>

		<p>Эта функция устарела и в Linux 2.4 была заменена на parport_negotiate.</p>

		<p>Полную версию перевода,  оформленную аналогично исходному документу и содержащую все три части, опубликованные в блоге, можно найти по ссылке: <a href="http://stupin.su/twaugh-parport/ru/">Подсистема параллельного порта Linux 2.4</a>.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Тим Во. Подсистема параллельного порта Linux 2.4 - часть 3, parport - справочник программного интерфейса драйвера параллельного порта Linux, 2000">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="jinja2,python,django,alembic,bottle,wtforms,перевод,sqlalchemy" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2017-08-06 -->
		<title>Тьяго Авелино. Bottle - полный веб-стек без Django, 2014</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Тьяго Авелино. Bottle - полный веб-стек без Django, 2014</h1>

		<p>Перевод статьи: <a href="http://www.avelino.xxx/2014/12/bottle-full-stack-without-django">Bottle, full stack without Django</a></p>

		<p>Автор: Тьяго Авелино (Thiago Avelino)</p>

		<p>Эта заметка в блоге основана на лекции, которую я прочитал здесь, в Бразилии. Посмотрите <a href="https://speakerdeck.com/avelino/bottle-o-full-stack-sem-django">слайды</a>!</p>

		<h2>1. Веб-микрофреймворк Bottle</h2>

		<p>Bottle - это веб-микрофреймворк, совместимый с WSGI, который зависит только от стандартной библиотеки Python и совместим с Python версий 2.6, 2.7, 3.2, 3.3 и 3.4. Весь исходный текст фреймворка умещается в <a href="https://github.com/defnull/bottle/blob/master/bottle.py">одном файле</a>. Он был создан Марселем Хеллкэмпом (Marcel Hellkamp - <a href="https://github.com/defnull">@defnull</a>) и поддерживается <a href="https://github.com/orgs/bottlepy/people">сообществом</a>, образовавшимся вокруг этого фреймворка.</p>

		<p><a href="https://www.djangoproject.com/">Django</a> - это прагматичный фреймворк для быстрой веб-разработки, который написан на Python, использует стандарт MTV (model-template-view - модель-шаблон-представление). Изначально он был создан как система для управления сайтом журнала в городе Лоуренс, в Канзасе. Стал проектом с открытым исходным кодом, был опубликован под лицензией BSD в 2005 году. Название Django фреймворк получил в честь джазового музыканта Джанго Рейнхардта. Django стал очень известен благодаря поставке с "батарейкам", то есть благодаря нескольким библиотекам, добавленным к основному коду фреймворка для упрощения разработки. Вместе с фреймворком эти библиотеки сформировали так называемый "полный стек".</p>

		<p>Прагматичный - значит ориентированный на решение практических, реальных задач с чётко определённой целью. Другими словами, команда разработчиков Django приняла некоторые архитектурные решения, а пользователи Django следуют этой архитектуре, не имея возможности легко её поменять.</p>

		<p>Хорошо ли, если вместе с веб-фреймворком поставляются "батарейки"? Если вы согласны использовать всё, что даёт вам фреймворк, то ответ - да. Однако, не все веб-проекты одинаковы.</p>

		<p>В большинстве проектов используется не более 80% возможностей Django. В тех случаях, когда используется не более 50% возможностей, мы вынуждены платить за все, что было предусмотрено архитектурой Django. То есть теряем в производительности, потому что в Django имеется множество модулей, которые не используются, но по-прежнему продолжают работать. Когда же мы используем микрофреймворк, мы берём на себя роль архитектора приложения. Поскольку у нас нет предопределённой архитектуры, нам нужно время, чтобы определить архитектуру приложения.</p>

		<p>Все пакеты Python, которые имеются в библиотеке Django, в микрофреймворке могут быть заменены!</p>

		<ul>
			<li>ORM - <a href="http://www.sqlalchemy.org/">SQLAlchemy</a> в <a href="https://github.com/iurisilvio/bottle-sqlalchemy">bottle-sqlalchemy</a></li>

			<li>Формы - <a href="https://wtforms.readthedocs.org/en/latest/">WTForms</a></li>

			<li>Шаблонизатор - <a href="http://jinja.pocoo.org/docs/dev/">Jinja2</a>, <a href="http://www.makotemplates.org/">mako</a> и т.п.</li>

			<li>Миграции - <a href="http://alembic.readthedocs.org/en/latest/">Alembic</a></li>
		</ul>

		<h2>2. SQLAlchemy</h2>

		<p>SQLAlchemy существовал до Django (<a href="https://github.com/zzzeek/sqlalchemy/commit/ec052c6a1f1fb0236bd367c510d82f076cb67bc9">да, до Django</a>) и начиная с 2005 года появилась команда, которая стала заниматься разработкой ORM. Команда же разработчиков Django занимается одновременно и разработкой фреймворка и разработкой ORM. Я думаю, что не стоит говорить о том, что результат работы специалистов обычно бывает лучше, чем результат работы универсалов.</p>

		<p>Структура модели:</p>

		<pre class="code">class Entity(Base):
    __tablename__ = 'entity'
    id = Column(Integer, Sequence('id_seq'), primary_key=True)
    name = Column(String(50))

    def __init__(self, name):
        self.name = name

    def __repr__(self):
        return "&lt;Entity('%d', '%s')&gt;" % (self.id, self.name)</pre>

		<h2>3. WTForms</h2>

		<p>Обходное решение для тех, кто не использует Django и кому нужно работать с формами - это WTForms, которые были созданы в 2008 году и поддержка которых продолжается до сих пор!</p>

		<p>Структура формы:</p>

		<pre class="code">class UserForm(Form):
    name = TextField(validators=[DataRequired(), Length(max=100)])
    email = TextField(validators=[DataRequired(), Length(max=255)])</pre>

		<h2>4. Шаблонизатор</h2>

		<p>Jinja2 - это современный удобный для дизайнеров язык шаблонизации для Python, который был создан по образцу шаблонов Django. Он быстрый, широко используется и может быть дополнительно защищён изоляцией рабочего окружения.</p>

		<p>Структура шаблона:</p>

		<pre class="code">&lt;title&gt;{% block title %}{% endblock %}&lt;/title&gt;
&lt;ul&gt;
{% for user in users %}
  &lt;li&gt;&lt;a href="{{ user.url }}"&gt;{{ user.username }}&lt;/a&gt;&lt;/li&gt;
{% endfor %}
&lt;/ul&gt;</pre>

		<h2>5. Миграция</h2>

		<p>Использование Alembic начинается с создания среды миграции. Это каталог сценариев, которые относятся к отдельному приложению. Среда миграции создаётся единожды, а затем поддерживается совместно с исходным кодом самого приложения.</p>

		<p>Структура миграции:</p>

		<pre class="code">revision = '1975ea83b712'
down_revision = None

from alembic import op
import sqlalchemy as sa

def upgrade():
    pass

def downgrade():
    pass</pre>

		<p>Как создать обновление и откат:</p>

		<pre class="code">def upgrade():
    op.create_table(
        'account',
        sa.Column('id', sa.Integer, primary_key=True),
        sa.Column('name', sa.String(50), nullable=False),
        sa.Column('description', sa.Unicode(200)),
    )

def downgrade():
    op.drop_table('account')</pre>

		<p>Структура модификации таблицы:</p>

		<pre class="code">"""
$ alembic revision -m "Add a column"
"""

revision = 'ae1027a6acf'
down_revision = '1975ea83b712'

from alembic import op
import sqlalchemy as sa

def upgrade():
    op.add_column('account', sa.Column('last_transaction_date', sa.DateTime))

def downgrade():
    op.drop_column('account', 'last_transaction_date')</pre>

		<h2>6. Заключение</h2>

		<p>Здесь было продемонстрировано всё, что можно найти в стеке Django. Я писал эту заметку для не для того, чтобы принизить Django. Я лишь показал, что существуют другие полностековые решения для разработки приложений. Многие люди используют Django, не понимая экосистемы Python. В наше время Django предоставляет множество готовых решений, что заставляет некоторых разработчиков лениться и не наращивать мастерство в проектировании архитектуры приложения.</p>

		<p>Помогайте Bottle. Мы - растущее сообщество. Чтобы внести свой вклад в код Bottle, обратитесь к списку открытых задач. В случае сомнений можно обратиться в список рассылки или в IRC-канал.</p>

		<p><a href="http://bottlepy.org/docs/dev/development.html#get-involved">ПРИСОЕДИНЯЙТЕСЬ</a></p>

		<h2>7. Примечания переводчика</h2>

		<p>Считаю, что в статье тема не раскрыта. Не понятно, какая такая особенная архитектура приложения имелась в виду, которая никак не сочетается с Django. Перечислено несколько средств, которые в чём-то заменяют средства, имеющиеся в Django. Без сомнений, SQLAlchemy заткнёт за пояс джанговский ORM. Безусловно, Jinja2 - очень быстрый шаблонизатор, быстрее джанговского. Но стоит иметь в виду, что в Django все эти средства глубоко интегрированы друг с другом.</p>

		<p>Например, в Django есть модельные формы, которые позволяют не создавать подробное описание формы, а автоматически получить это описание из описания модели. При необходимости модельную форму можно даже чуть-чуть подправить, указав какие поля не нужно отображать на форме, какие дополнительные поля, которых нет в модели, нужно добавить к форме, в каком порядке должны следовать поля, можно переопределить отдельные поля формы, определить особые методы валидации и т.д. В простейшем случае описание всей формы ограничивается парой строчек, но если нужно - можно получить гибкость, которую дают обычные формы.</p>

		<p>Другой пример - в Django миграции можно сгенерировать автоматически. Автоматическая генерация даже умеет определять переименованные поля. А если же автоматика не сработала корректно, то автоматически сгенерированный код миграции можно подправить и руками.</p>

		<p>Наконец, в комплекте с Django имеется административный интерфейс, для которого можно определять собственные классы для редактирования таблиц. В большинстве случаев этот административный интерфейс позволяет сэкономить время на создании шаблонов и написании представлений для просмотра и редактирования таблиц. Да, его возможности ограничены, но ведь в комплекте с Bottle ничего подобного нет, а если и есть в сторонних модулях, то наверняка такие модули тоже окажутся недостаточно интегрированными с ORM или модулем форм - придётся писать дополнительный код, который предоставит необходимую информацию этому модулю.</p>

		<p>Я сам в своих проектах использую Django, но для некоторых задач он действительно избыточен. Например, в одной из прошлых своих заметок я писал <a href="../mapnik-bottle/">Тайловый сервер на основе Python, Mapnik и Bottle</a>. Денис Рыков, материалами которого я воспользовался, тоже писал тайловый сервер, воспользовавшись фреймворком Bottle. Для себя я решил, что если приложение не работает с собственной базой данных, а берёт информацию из сторонних источников и занимается лишь её преобразованием, или выполняет какие-то действия по требованию, то лучше использовать Bottle, т.к. в нём нет избыточных возможностей, а сам он обладает минимумом зависимостей и работает с любой версией Python.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Настройка кэширующего DNS-сервера BIND в связке с resolvconf">Написать автору</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

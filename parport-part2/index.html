<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="lp,linux,parport,перевод,параллельный порт,ppdev" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2019-04-21 -->
		<title>Тим Во. Подсистема параллельного порта Linux 2.4 - часть 2, ppdev - драйверы устройств, работающие в пространстве пользователя, 2000</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Тим Во. Подсистема параллельного порта Linux 2.4 - часть 2, ppdev - драйверы устройств, работающие в пространстве пользователя, 2000</h1>

		<p>Перевод статьи: <a href="https://people.redhat.com/twaugh/parport/html/parportguide.html">The Linux 2.4 Parallel Port Subsystem</a></p>

		<p>Автор: Тим Во (Tim Waugh)</p>

		<p>Предыдущая часть: <a href="../parport-part1/">Подсистема параллельного порта Linux 2.4 - часть 1, обзор</a></p>

		<h2>1. Драйверы устройств, работающие в пространстве пользователя</h2>

		<h3>1.1. Введение в ppdev</h3>

		<p>Принтер доступен через /dev/lp0, а параллельный порт доступен через /dev/parport0. Разница заключается в уровне управления, который можно осуществлять по проводам в кабеле параллельного порта.</p>

		<p>Программа, работающая в пространстве пользователя (такая как диспетчер печати), может отправлять байты по «протоколу принтера» при помощи драйвера принтера. Вкратце это означает, что для каждого байта настраиваются восемь линий данных, затем линия «строб» сообщает принтеру о необходимости прочитать данные, затем принтер устанавливает линию «подтверждение», чтобы сообщить, что он получил байт. Драйвер принтера также позволяет программе, работающей в пространстве пользователя, читать байты в полубайтовом режиме, в котором от периферийного устройства на компьютер можно передавать данные по половине байта за раз (из-за чего режим оказывается довольно медленным).</p>

		<p>В отличие от драйвера принтера, драйвер ppdev (доступный через /dev/parport0) позволяет:</p>

		<ul>
			<li>проверять линии статуса,</li>

			<li>задавать линии управления,</li>

			<li>задавать/проверять линии данных (и управлять направлением линий данных),</li>

			<li>ожидать прерывания (срабатывает при изменении одной из линий статуса),</li>

			<li>узнавать, сколько произошло новых прерываний,</li>

			<li>задавать ответ на прерывание,</li>

			<li>использовать согласование IEEE 1284 (чтобы сообщить периферийному устройству, какой режим передачи использовать),</li>

			<li>передавать данные с использованием указанного режима IEEE 1284.</li>
		</ul>

		<h3>1.2. Драйвер в пространстве ядра или в пространстве пользователя?</h3>

		<p>Решение о том, писать ли драйвер, работающий в пространстве ядра, или драйвер, работающий в пространстве пользователя, зависит от нескольких факторов. Один из основных критериев - это скорость: драйверы, работающие в пространстве ядра, работают быстрее, поскольку они не вытесняются другими процессами, в отличие от приложений в пространстве пользователя.</p>

		<p>Другой критерий - это лёгкость разработки. В большинстве случаев проще написать драйвер, который будет работать в пространстве пользователя, потому что (а) одно неверное движение не приведёт к аварии всего компьютера, (б) имеется доступ к пользовательским библиотекам (таким как библиотека C), и (в) его проще отлаживать.</p>

		<h3>1.3. Интерфейс программирования</h3>

		<p>Интерфейс ppdev во многом совпадает с интерфейсом символьных специальных устройств, т.к. он тоже поддерживает функции open, close, read, write и ioctl. Константы для команд ioctl имеются в файле include/linux/ppdev.h.</p>

		<h4>1.3.1. Начало и завершение: open и close</h4>

		<p>Файл устройства /dev/parport0 представляет любое устройство, подключенное к parport0 - первому параллельному порту в системе. Каждый раз при открытии файла устройства, он представляет (для процесса, выполняющего открытие) другое устройство. Он также может быть открыт более одного раза, но в любой момент только один экземпляр действительно будет управлять параллельным портом. Процесс, который открыл /dev/parport0, работает с параллельным портом через механизм совместного доступа таким же образом, как и любой другой драйвер устройства. Драйвер в пространстве пользователя может работать с параллельным портом совместно как с драйверами устройств пространства ядра, так и с драйверами пространства пользователя.</p>

		<h4>1.3.2. Управление: ioctl</h4>

		<p>Большая часть управления выполняется через вызовы ioctl. При помощи ioctl драйвер пространства пользователя может управлять как драйвером ppdev в ядре, так и самим физическим параллельным портом. Вызов ioctl принимает в качестве параметров дескриптор файла (который был получен при открытии файла устройства), команду, и (не обязательный) указатель на некоторые данные.</p>

		<dt>PPCLAIM</dt>

		<dd>Затребовать доступ к порту. Необходимо сделать это перед тем, как приступить к работе с параллельным портом. Отметим, что некоторые операции действуют только на драйвер ppdev, но не на порт - например, PPSETMODE. Они могут осуществляться только в тот момент, когда доступ к порту не затребован.</dd>

		<dt>PPEXCL</dt>

		<dd>
			<p>Указывает драйверу ядра запретить любое совместное использование с другими драйверами, то есть запрашивается исключительный доступ. Команда PPEXCL действует только пока доступ к порту ещё никем не затребован. Последующий запрос ioctl PPCLAIM может завершится неудачно, т.к. к этому моменту доступ к порту может быть предоставлен какому-то другому драйверу.</p>

			<p>Большинству драйверов устройств не требуется эксклюзивный доступ к порту. Такой доступ предоставляется в случае, если он действительно нужен. Например, это могут быть устройства, которым требуется доступ на продолжительное время (многие секунды).</p>
			<p>Отметим, что ioctl PPEXCL на самом деле не запрашивает доступ к порту - действие откладывается до тех пор, пока не будет выполнена команда ioctl PPCLAIM.</p>
		</dd>

		<dt>PPRELEASE</dt>

		<dd>Освобождает порт. Освобождение порта отменяет ранее затребованный доступ к порту. Это позволит драйверам других устройств общаться с их устройствами (если они есть).</dd>

		<dt>PPYIELD</dt>

		<dd>
			<p>Уступить порт другому драйверу. Этот ioctl является сокращенной записью освобождения доступа к порту и немедленного его повторного затребования. Это позволяет другим драйверам получить возможность пообщаться с их устройствами, но после этого доступ к порту вернётся обратно. Пример использования можно найти в драйвере принтера, работающем в пространстве пользователя: как только были записаны несколько символов, можно на некоторое время передать порт драйверу другого устройства, но если символы для отправки на принтер ещё есть, то драйвер принтера желает вернуть доступ к порту как можно раньше.</p>

			<p>Важно не требовать параллельный порт надолго, потому что драйверам других устройств не останется времени на обслуживание их устройств. Если ваше устройство не позволяет использовать совместный доступ к порту, лучше затребовать параллельный порт в исключительный доступ (см. PPEXCL).</p>
		</dd>

		<dt>PPNEGOT</dt>

		<dd>
			<p>Производит согласование одного из режимов IEEE 1284. Согласование - это метод, по которому компьютер и периферийное устройство принимают решение об используемом протоколе передачи данных.</p>

			<p>Устройство, совместимое с IEEE 1284, начинает работу в совместимом режиме, а затем компьютер может согласовать другой режим (например, ECP).</p>
			
			<p>Параметр ioctl должен быть указателем на int. В файле incluce/linux/parport.h определены следующие значения:</p>

			<ul>
				<li>IEEE1284_MODE_COMPAT</li>

				<li>IEEE1284_MODE_NIBBLE</li>

				<li>IEEE1284_MODE_BYTE</li>

				<li>IEEE1284_MODE_EPP</li>

				<li>IEEE1284_MODE_ECP</li>

			</ul>

			<p>ioctl PPNEGOT на самом деле выполняет два действия: производит согласование режима и настраивает поведение последующих вызовов read/write, которые будут работать в этом режиме (но см. также PPSETMODE).</p>
		</dd>

		<dt>PPSETMODE</dt>

		<dd>
			<p>Задаёт режим передачи IEEE 1284, который будет использоваться вызовами read и write.</p>

			<p>Параметр ioctl должен быть указателем на int.</p>
		</dd>

		<dt>PPGETMODE</dt>

		<dd>Возвращает текущий режим IEEE 1284, используемый read и write.</dd>

		<dt>PPGETTIME</dt>

		<dd>
			<p>Возвращает значение таймаута. Вызовы read и write завершаются, если периферийное устройство не ответит достаточно быстро. ioctl PPGETTIME возвращает время, в течение которого периферийное устройство считается доступным, даже если оно не отвечает.</p>

			<p>Параметр ioctl должен быть указателем на структуру timeval.</p>
		</dd>

		<dt>PPSETTIME</dt>

		<dd>Задаёт таймаут. Параметр ioctl должен быть указателем на структуру timeval.</dd>

		<dt>PPGETMODES</dt>

		<dd>Запрашивает возможности оборудования (то есть поле modes из структуры parport).</dd>

		<dt>PPSETFLAGS</dt>

		<dd>
			<p>Задаёт флаги устройства ppdev, которые могут влиять на последующие операции ввода-вывода. Доступны следующие флаги:</p>

			<ul>
				<li>PP_FASTWRITE</li>

				<li>PP_FASTREAD</li>

				<li>PP_W91284PIC</li>

				<li>PPWCONTROL</li>
			</ul>

			<p>Задаёт линии управления. Параметр ioctl - это указатель на unsigned char, содержащий результат битового ИЛИ над определениями из include/linux/parport.h, соответствующих управляющих линий.</p>
		</dd>

		<dt>PPRCONTROL</dt>

		<dd>
			<p>Возвращает последнее значение, записанное в регистр управления, в виде unsigned char: каждый бит соответствует управляющий линии (некоторые из них не используются). Параметр ioctl должен быть указателем на unsigned char.</p>

			<p>При этом оборудование фактически не затрагивается, т.к. последнее записанное значение запоминается программно. Так сделано, поскольку некоторое аппаратное обеспечение параллельных портов не предоставляет доступ к регистру управления.</p>

			<p>Биты управляющих линий определены в include/linux/parport.h:</p>

			<ul>
				<li>PARPORT_CONTROL_STROBE</li>

				<li>PARPORT_CONTROL_AUTOFD</li>

				<li>PARPORT_CONTROL_SELECT</li>

				<li>PARPORT_CONTROL_INIT</li>
			</ul>
		</dd>

		<dt>PPFCONTROL</dt>

		<dd>
			<p>Переключить управляющие линии. Поскольку часто бывает нужно изменить один из управляющих сигналов, не трогая остальные, было бы не очень эффективно для драйвера в пространстве пользователя сначала воспользоваться PPRCONTROL, внести изменения и затем воспользоваться PPWCONTROL. Конечно, каждому драйверу придётся запоминать состояние управляющих линий (они не могут быть изменены из другого места), но для предоставления PPRCONTROL самому ppdev тоже приходится запоминать состояние управляющих линий.</p>

			<p>ioctl PPFCONTROL для переключения управляющих линий аналогичен PPWCONTROL, но воздействует лишь на ограниченный набор управляющих линий. Параметр ioctl - это указатель на структуру ppdev_frob_struct:</p>

			<pre class="code">struct ppdev_frob_struct {
	unsigned char mask;
	unsigned char val;
};</pre>

			<p>Поля mask и val - это битовое ИЛИ над именами управляющих линий (таких же, как в PPWCONTROL). PPFCONTROL выполняет следующую операцию:</p>

			<pre class="code">new_ctr = (old_ctr &amp; ~mask) | val;</pre>

			<p>Другими словами, сигналы, указанные в mask, примут значения, указанные в val.</p>
		</dd>

		<dt>PPRSTATUS</dt>

		<dd>Возвращает unsigned char, содержащий биты для каждой из активных линий состояния (например, PARPORT_STATUS_BUSY). Параметр ioctl должен быть указателем на unsigned char.</dd>

		<dt>PPDATADIR</dt>

		<dd>
			<p>Управление направлением линий данных. Обычно параллельный порт компьютера управляет линиями данных, но в байтовом режиме передачи от периферийного устройства на компьютер нужно отключить это управление и позволить периферийному устройству управлять этими сигналами. (Если управление параллельным портом со стороны компьютера останется активным, то порт может повредиться.)</p>

			<p>Этот вызов бывает нужен только в сочетании с PPWDATA или PPRDATA.</p>

			<p>Параметр ioctl - это указатель на int. Если int - ноль, управление линиями данных включается (прямое направление). Если же int - не ноль, то управление линиями данных отключается (обратное направление).</p>
		</dd>

		<dt>PPWDATA</dt>

		<dd>Задаёт линии данных (если они находится в режиме прямого направления). Параметр ioctl - указатель на unsigned char.</dd>

		<dt>PPRDATA</dt>

		<dd>Читает линии данных (если они находится в режиме обратного направления). Параметр ioctl - указатель на unsigned char.</dd>

		<dt>PPCLRIRQ</dt>

		<dd>
			<p>Очищает счётчик прерываний. Драйвер ppdev хранит счётчик произошедших прерываний. PPCLRIRQ сохранит этот счётчик в int, указатель на который передан в качестве параметра ioctl.</p>

			<p>После этого счётчик прерываний сбрасывается в ноль.</p>
		</dd>

		<dt>PPWCTLONIRQ</dt>

		<dd>
			<p>Задаёт признак ответа. После того, как произойдёт прерывание, обработчик должен выставить линии управления в соответствии с запросом. Параметр ioctl - указатель на unsigned char, который интерпретируется так же, как в PPWCONTROL.</p>

			<p>Этот ioctl введён по соображениям скорости. Без этого ioctl соответствующее прерывание начнёт обрабатываться в обработчике прерываний, переключится через poll или select на драйвер в пользовательском пространстве, а затем переключится обратно в ядро, чтобы обработать PPWCONTROL. Выполнение всех процедур в обработчике прерывания значительно быстрее.</p>
		</dd>

		<h4>1.3.3. Передача данных: read и write</h4>

		<p>Передача данных при помощи read и write осуществляется очевидным образом. Данные передаются с использованием текущего режима IEEE 1284 (см. ioctl PPSETMODE). В режимах, которые позволяют передавать данные только в одном направлении, будет работать только соответствующая функция.</p>

		<h4>1.3.4. Ожидание событий: poll и select</h4>

		<p>Драйвер ppdev позволяет драйверам устройств, работающим в пространстве пользователя, ожидать прерываний при помощи poll (и select, который реализуется средствами poll).</p>

		<p>Когда драйвер устройства, работающий в пространстве пользователя, захочет подождать прерывания, он засыпает, выполняя poll. Когда поступает прерывание, ppdev будит его (событием «read», хотя, строго говоря, читать на самом деле нечего).</p>

		<h3>1.4. Примеры</h3>

		<p>Имеющиеся здесь два примера описывают процесс написания простого драйвера принтера для ppdev. В первом примере используется функция write, а во втором примере - непосредственная манипуляция линиями данных и управления.</p>

		<p>Сначала нужно открыть устройство.</p>

		<pre class="code">int drive_printer (const char *name)
{
    int fd;
    int mode; /* Потребуется позже. */

    fd = open (name, O_RDWR);
    if (fd == -1) {
	perror ("open");
	return 1;
    }</pre>

		<p>Параметр name из вышеприведённого фрагмента должен быть строкой, содержащей имя файла устройства параллельного порта, например "/dev/parport0". (Если файлов /dev/parport нет, то их можно создать при помощи mknod. Это файлы специальных символьных устройств со старшим номером 99.)</p>

		<p>Прежде чем работать с портом, нужно получить к нему доступ.</p>

		<pre class="code">if (ioctl (fd, PPCLAIM)) {
	perror ("PPCLAIM");
	close (fd);
	return 1;
    }</pre>

		<p>Наш драйвер принтера будет просто копировать свой ввод (со стандартного потока ввода) на принтер. Сделать это можно одним из двух способов. Первый способ - передать всё драйверу, работающему в ядре, зная что принтер работает по протоколу, который в IEEE 1284 называется режимом совместимости.</p>

		<pre class="code">/* Переключимся в совместимый режим. (Фактически этого делать 
     * не нужно, поскольку в начале всегда используется совместимый режим,
     * но здесь демонстрируется использование PPNEGOT.) */
    mode = IEEE1284_MODE_COMPAT;
    if (ioctl (fd, PPNEGOT, &amp;mode)) {
	perror ("PPNEGOT");
	close (fd);
	return 1;
    }

    for (;;) {
	char buffer[1000];
	char *ptr = buffer;
	size_t got;

	got = read (0 /* стандартный поток ввода */, buffer, 1000);
	if (got &lt; 0) {
	    perror ("read");
	    close (fd);
	    return 1;
	}

	if (got == 0)
	    /* Конец ввода */
	    break;

	while (got &gt; 0) {
	    int written = write_printer (fd, ptr, got);

	    if (written &lt; 0) {
		perror ("write");
		close (fd);
		return 1;
	    }

	    ptr += written;
	    got -= written;
	}
    }</pre>

		<p>Определение функция write_printer в фрагменте выше не показано. Это сделано специально, поскольку приведённый в фрагменте главный цикл может использоваться с обоими рассматриваемыми методами управления принтером. Вот первая реализация write_printer:</p>

		<pre class="code">ssize_t write_printer (int fd, const void *ptr, size_t count)
{
    return write (fd, ptr, count);
}</pre>

		<p>При помощи функции write данные передаются драйверу, работающему в пространстве ядра. Дальше он обрабатывает их по протоколу принтера.</p>

		<p>Теперь давайте попробуем пойти более сложным путём! В рассматриваемом примере нет никаких причин, чтобы делать что-либо кроме вызова write, потому что принтер работает по протоколу IEEE 1284. С другой стороны, этот пример не требует наличия драйвера в пространстве пользователя, потому что уже есть один, который работает в пространстве ядра. В целях иллюстрации, попробуем представить, что принтер работает по протоколу, который в Linux ещё не реализован.</p>

		<p>Получим альтернативную реализацию write_printer (для краткости обработка ошибок не выполняется):</p>

		<pre class="code">ssize_t write_printer (int fd, const void *ptr, size_t count)
{
    ssize_t wrote = 0;

    while (wrote &lt; count) {
	unsigned char status, control, data;
	unsigned char mask = (PARPORT_STATUS_ERROR
			      | PARPORT_STATUS_BUSY);
	unsigned char val = (PARPORT_STATUS_ERROR
			      | PARPORT_STATUS_BUSY);
	struct ppdev_frob_struct frob;
	struct timespec ts;

	/* Подождём готовности принтера */
	for (;;) {
	    ioctl (fd, PPRSTATUS, &amp;status);

	    if ((status &amp; mask) == val)
		break;

	    ioctl (fd, PPRELEASE);
	    sleep (1);
	    ioctl (fd, PPCLAIM);
	}

	/* Задаём линии данных */
	data = * ((char *) ptr)++;
	ioctl (fd, PPWDATA, &amp;data);

	/* Немного подождём */
	ts.tv_sec = 0;
	ts.tv_nsec = 1000;
	nanosleep (&amp;ts, NULL);

	/* Стробирующий импульс */
	frob.mask = PARPORT_CONTROL_STROBE;
	frob.val = PARPORT_CONTROL_STROBE;
	ioctl (fd, PPFCONTROL, &amp;frob);
	nanosleep (&amp;ts, NULL);

	/* Конец импульса */
	frob.val = 0;
	ioctl (fd, PPFCONTROL, &amp;frob);
	nanosleep (&amp;ts, NULL);

	wrote++;
    }

    return wrote;
}</pre>

		<p>Чтобы продемонстрировать интерфейс ppdev слегка подробнее, приведём небольшой фрагмент кода, который предназначен для имитации протокола принтера со стороны принтера.</p>
		
		<pre class="code">for (;;)
    {
      int irqc;
      int busy = nAck | nFault;
      int acking = nFault;
      int ready = Busy | nAck | nFault;
      char ch;

      /* Задаём управляющие линии на случай прерывания */
      ioctl (fd, PPWCTLONIRQ, &amp;busy);

      /* Теперь мы готовы */
      ioctl (fd, PPWCONTROL, &amp;ready);

      /* Ждём прерывания */
      {
	fd_set rfds;
	FD_ZERO (&amp;rfds);
	FD_SET (fd, &amp;rfds);
	if (!select (fd + 1, &amp;rfds, NULL, NULL, NULL))
	  /* Сигнал получен? */
	  continue;
      }

      /* На линиях управления выставляется сигнал "занято" */

      /* Читаем данные */
      ioctl (fd, PPRDATA, &amp;ch);

      /* Очищаем прерывание */
      ioctl (fd, PPCLRIRQ, &amp;irqc);
      if (irqc &gt; 1)
	fprintf (stderr, "Аххх! Потеряно %d прерываний!\n",
	 irqc - 1);

      /* Подтверждаем его */
      ioctl (fd, PPWCONTROL, &amp;acking);
      usleep (2);
      ioctl (fd, PPWCONTROL, &amp;busy);

      putchar (ch);
    }</pre>

		<p>А вот пример (тоже без обработки ошибок), который демонстрирует, как читать данные из порта в режиме ECP, с необязательным начальным согласованием режима ECP.</p>

		<pre class="code">{
      int fd, mode;
      fd = open ("/dev/parport0", O_RDONLY | O_NOCTTY);
      ioctl (fd, PPCLAIM);
      mode = IEEE1284_MODE_ECP;
      if (negotiate_first) {
	ioctl (fd, PPNEGOT, &amp;mode);
	/* PPSETMODE не требуется */
      } else {
	ioctl (fd, PPSETMODE, &amp;mode);
      }

      /* Теперь делаем с fd всё, что нужно */
      close (0);
      dup2 (fd, 0);
      if (!fork()) {
	/* Потомок */
	execlp ("cat", "cat", NULL);
	exit (1);
      } else {
	/* Родитель */
	wait (NULL);
      }

      /* Ну вот и закончили */
      ioctl (fd, PPRELEASE);
      close (fd);
    }</pre>

		<p><a href="mailto:vladimir@stupin.su?subject=Тим Во. Подсистема параллельного порта Linux 2.4 - часть 2, ppdev - драйверы устройств, работающие в пространстве пользователя, 2000">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="python,django,перевод" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2017-07-23 -->
		<title>Джеймс Беннет. Правильная обработка choices в полях моделей Django, 2007</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Джеймс Беннет. Правильная обработка choices в полях моделей Django, 2007</h1>

		<p>Перевод статьи: <a href="http://www.b-list.org/weblog/2007/nov/02/handle-choices-right-way/">Handle choices the right way</a></p>

		<p>Автор: Джеймс Беннет (James Bennett)</p>

		<p>Часто бывает нужно воспользоваться полем модели, которое будет принимать ограниченный набор значений. Например, поле выбора штата США, что логично, должно разрешать только значения, соответствующие действительно существующим штатам США. В ORM Django это реализуется при помощи <a href="https://docs.djangoproject.com/en/1.11/ref/models/fields/#choices">аргумента choices</a> в определении поля. В общем случае это - наиболее простое решение.</p>

		<p>Но это решение не всегда идеальное: хотя со строковыми значениями (упомянутые выше штаты США <a href="http://django-localflavor.readthedocs.io/en/latest/localflavor/us/#data">в Django могут быть реализованы</a> в виде простого двухбуквенного почтового кода вроде "VA" или "KS") не возникает проблем, с числовыми значениями возникают сложности. Например, в моём блоге используется модель Entry (если интересно - см. полный исходный текст в <a href="https://github.com/mafix/coltrane-blog/blob/master/coltrane/models.py">репозитории Google Code</a>), в которой есть поле "status", позволяющее отличать три разных типа записей:</p>

		<ol>
			<li>"Live" - записи, которые опубликованы на сайте.</li>

			<li>"Draft" - записи, которые находятся в процессе подготовки и ещё не опубликованы. Когда они будут дописаны, их статус можно будет поменять на "Live".</li>

			<li>"Hidden" - записи, которые по какой-либо причине были скрыты. Если записи нужно оставить в базе данных, но они не должны быть опубликованными.</li>
		</ol>

		<p>К слову, я настоятельно рекомендую не удалять содержимое из базы данных. Никогда не знаешь, когда оно может потребоваться снова. И хотя можно <a href="https://ltslashgt.com/2007/07/18/undelete-in-django/">реализовать функцию восстановления записей</a>, гораздо проще просто включить или выключить признак публикации.</p>

		<p>Теперь запишем этот набор опций в виде кортежа choices наиболее очевидным образом:</p>

		<pre class="code">STATUS_CHOICES = (
    (1, 'Live'),
    (2, 'Draft'),
    (3, 'Hidden'),
)</pre>

		<p>Для этих значений не так-то просто придумать строковые аббревиатуры (по крайней мере, ни одно из них не может быть интернационализировано), поэтому выходом может оказаться использование целочисленных значений. В таком случае его можно просто добавить к модели:</p>

		<pre class="code">class Entry(models.Model)
    # ...несколько других полей...
    status = models.IntegerField(choices=STATUS_CHOICES)</pre>

		<p>Можно чуть-чуть улучшить этот код, так чтобы по умолчанию у записей проставлялось значение “Live”:</p>

		<pre class="code">status = models.IntegerField(choices=STATUS_CHOICES, default=1)</pre>

		<p>Теперь можно легко выбрать только опубликованные записи, выполнив такой запрос:</p>

		<pre class="code">live_entries = Entry.objects.filter(status=1)</pre>

		<p>Можно даже реализовать <a href="https://docs.djangoproject.com/en/1.11/topics/db/managers/#custom-managers">собственный менеджер запросов</a>, который заменит метод get_query_set() так, чтобы он возвращал только опубликованные записи (<a href="https://github.com/mafix/coltrane-blog/blob/master/coltrane/managers.py">как было сделано здесь</a>).</p>

		<p>Но у этого подхода есть большая проблема: теперь в приложении повсюду используются "магические числа".</p>

		<h2>1. Плохая магия</h2>

		<p>"Магические числа" - это любые числовые константы (или любые другие непонятные значения), которые явным образом встречаются в коде. В данном случае значение статуса "Live" - 1 - используется по меньшей мере уже в двух местах: первый раз в объявлении поля модели (в качестве значения по умолчанию) и, даже если мы напишем собственный менеджер запросов для выбора опубликованных записей, как минимум ещё один раз для фильтрации в условии status=1. И это даже если мы просто хотим удобно работать с опубликованными записями. Если же нам когда-нибудь понадобится, скажем, метод-менеджер или QuerySet для черновиков, нам придётся разбросать во множестве мест ещё одно число.</p>

		<p>Это плохо по нескольким причинам. Во-первых, что самое важное, нарушается <a href="http://wiki.c2.com/?DontRepeatYourself">принцип DRY</a> (Don't repeat yourself - не повторяйся), так как нужно повторять одно и то же "магическое" число во множестве мест. Во-вторых, есть риск нарушения родственного принципа <a href="http://c2.com/xp/OnceAndOnlyOnce.html">"Однажды и только единожды"</a>, поскольку легко попасть в ловушку при написании filter(status=1) более чем в одном месте. Наконец, в-третьих, возникают проблемы с поддержкой: нужно держать в уме - что означает это "магическое" значение и список всех мест, где оно используется (поскольку любое будущее изменение потребуется внести во все эти места одновременно).</p>

		<h2>2. Удаляем магию</h2>

		<p>Но остаётся проблема: как ссылаться на это значение без жёстко-закодированных повсюду "магических" чисел? В языках с перечисляемыми типами (такими как enum в C и его родственниках), это - легко решаемая проблема. В одном из этих языков нужно просто определить enum с именами различных вариантов и позволить языку использовать значениями.</p>

		<p>Но в Python нет подходящей замены для enum. Мы можем импортировать кортеж STATUS_CHOICES и записать фильтрацию следующим образом:</p>

		<pre class="code">live_entries = Entry.objects.filter(status=STATUS_CHOICES[0][0])</pre>

		<p>Но, несмотря на то, что мы больше не используем жёстко закодированные числовые значения, теперь мы опираемся на точное определение кортежа STATUS_CHOICES. Если в первый слот будет помещено какое-то другое значение (например, статус подтверждения записи главным редактором), то сломается всё, что ссылается на STATUS_CHOICES[0][0].</p>

		<p>Однако, можно просто определить набор констант:</p>

		<pre class="code">LIVE_STATUS = 1
DRAFT_STATUS = 2
HIDDEN_STATUS = 3</pre>

		<p>Теперь можно переопределить кортеж STATUS_CHOICES так, чтобы он опирался эти константы:</p>

		<pre class="code">STATUS_CHOICES = (
    (LIVE_STATUS, 'Live'),
    (DRAFT_STATUS, 'Draft'),
    (HIDDEN_STATUS, 'Hidden'),
)</pre>

		<p>А также, теперь можно импортировать и ссылаться на эти константы. Например, поле статуса теперь должно быть записано следующим образом:</p>

		<pre class="code">status = models.IntegerField(choices=STATUS_CHOICES, default=LIVE_STATUS)</pre>

		<p>Этими константами можно воспользоваться и для фильтрации только опубликованных записей:</p>

		<pre class="code">live_entries = Entry.objects.filter(status=LIVE_STATUS)</pre>

		<p>Черновики теперь можно отбирать, фильтруя их по условию status=DRAFT_STATUS. А скрытые записи можно фильтровать по условию status=HIDDEN_STATUS. Код становится более наглядным в двух аспектах:</p>

		<ol>
			<li>Больше нет разложенных повсюду "магических чисел", которые нужно специально обновлять. Одно изменение в определении одной или более констант - это всё, что нужно, чтобы обновить код (важно также обновить и базу данных, но это можно легко исправить одним запросом UPDATE).</li>

			<li>Код теперь стал гораздо понятнее: запрос с условием status=1 может значить что угодно, но запрос с условием status=LIVE_STATUS практически объясняет сам себя.</li>
		</ol>

		<h2>3. Инкапсуляция</h2>

		<p>Однако, можно внести ещё одно улучшение: инкапсулировать варианты статуса внутри модели Entry. Эти варианты логически "принадлежат" модели Entry и поэтому не стоит определять их отдельно или импортировать их отдельно от самой модели Entry. Поэтому можно переместить константы и кортеж с вариантами вовнутрь класса Entry:</p>

		<pre class="code">class Entry(models.Model):
    LIVE_STATUS = 1
    DRAFT_STATUS = 2
    HIDDEN_STATUS = 3
    STATUS_CHOICES = (
        (LIVE_STATUS, 'Live'),
        (DRAFT_STATUS, 'Draft'),
        (HIDDEN_STATUS, 'Hidden'),
    )
    # ...несколько других полей...
    status = models.IntegerField(choices=STATUS_CHOICES, default=LIVE_STATUS)</pre>

		<p>Теперь можно просто импортировать модель Entry и писать запросы следующим образом:</p>

		<pre class="code">live_entries = Entry.objects.filter(status=Entry.LIVE_STATUS)
draft_entries = Entry.objects.filter(status=Entry.DRAFT_STATUS)</pre>

		<p>Можно также сравнивать записи со значениями констант:</p>

		<pre class="code">if entry_object.status == Entry.LIVE_STATUS:
    # делаем что-то с опубликованной записью</pre>

		<h2>4. Подведём итоги</h2>

		<p>Хотя нужно набрать немного больше текста (поскольку сначала нужно определить константы, а затем объявить кортеж choices на их основе), это - лучший способ работы с целочисленными вариантами в полях моделей Django. Возможность ссылаться на константы как на атрибуты класса модели, наподобие Entry.LIVE_STATUS, вместо жёсткого кодирования "магических" чисел или работы с отдельной от класса структурой данных - это почти настолько наглядно, насколько возможно.</p>

		<h2>5. Примечания переводчика</h2>

		<p>Не задумывался над тем, как лучше оформлять кортежи для параметра choices в полях моделей Django.</p>

		<p>Не задумывался, видимо, потому что никогда до этого не приходилось фильтровать записи по значениям этого поля. И вот однажды такая необходимость возникла. Подумал, что использование в QuerySet'ах "магических чисел" не способствует наглядности кода и решил поискать - как же лучше оформить эти кортежи? В результате нашёл эту статью, которую и решил впоследствии перевести - вдруг кому-нибудь ещё пригодится? Многие ссылки в исходной статье протухли, поэтому заменил их на то, что удалось найти из ещё доступного.</p>

		<p><a href="mailto:vladimir@stupin.su?subject=Джеймс Беннет. Правильная обработка choices в полях моделей Django, 2007">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>

<html>
	<head>
		<meta http-equiv="Content-Type" content="plain/html; charset=UTF-8" />
		<link rel="stylesheet" href="../styles.css" type="text/css" />
		<meta name="keywords" content="bash,перевод" />
		<meta name="author" content="Владимир Ступин" />
		<!-- 2010-08-04 -->
		<title>Фил Хьюз. Преобразовать имена файлов к нижнему регистру, 2008</title>
	</head>
	<body>
		<p><a href="..">&larr;</a></p>

		<h1>Фил Хьюз. Преобразовать имена файлов к нижнему регистру, 2008</h1>

		<p>Перевод статьи: <a href="http://www.linuxjournal.com/content/convert-filenames-lowercase">Convert Filenames to Lowercase</a></p>

		<p>25 июля 2008, Фил Хьюз (Phil Hughes)</p>

		<p>Я собирался сказать, что я написал это вчера, но отметка времени файла указывает на то, что это было 22 ноября 1998. Ничего нового, ничего особенного, это просто работает.</p>

		<p>Вернёмся в старое-доброе время операционных систем, не понимавших разницы между NAME и name. В результате, если иногда приходится копировать файлы с гибких дисков (помните такие?), созданных на Давно Онемевшей Системе, можно получить свалку каталогов с именами файлов в верхнем регистре. Поскольку мы, опытные старожилы UNIX, пользуемся хитрой уловкой для вывода имён каталогов до имён файлов файлов по команде ls (а именно - начинаем имена каталогов с букв в верхнем регистре), наличие имён файлов с символами в верхнем регистре нас раздражает.</p>

		<p>Поскольку я слишком часто пользовался командой mv и ввод команд типа mv FILE.TXT file.txt меня окончательно изнурил, я написал этот сценарий. Я думал, что я просто сделал косметический ремонт, но на самом деле сценарий делает работу и в нём легко разобраться. (Номера строк приведены просто для того, чтобы на них ссылаться.)</p>

		<pre class="code">1   #!/bin/sh
 2   # lowerit
 3   # преобразовывает имена всех файлов в текущем каталоге к нижнему регистру
 4   # работает только над обычными файлами -- не меняет имена каталогов
 5   # запрашивает подтверждение перед заменой существующего файла
 6   for x in `ls`
 7   do
 8     if [ ! -f $x ]; then
 9       continue
10     fi
11     lc=`echo $x | tr '[A-Z]' '[a-z]'`
12     if [ $lc != $x ]; then
13       mv -i $x $lc
14     fi
15   done</pre>

		<p>Строка 6 начинает цикл (который заканчивается в строке 15). Команда ls возвращает список имён файлов, которые последовательно назначаются переменной оболочки x. if test (строки с 8 по 10) проверяет, является ли имя текущего файла именем простого файла. Если нет, остаток выражения в текущего прохода цикла пропускается.</p>

		<p>Если выполняется строка 11, то известно, что обрабатывается обычный файл. С помощью tr мы приводим имя файла в нижний регистр и присваиваем новое имя переменной оболочки lc. Затем в строке 12 происходит проверка, что имя файла в нижнем регистре отличается от исходного. Если это так, то выполняется 13 строка, которая меняет исходное имя файла на новое имя в нижнем регистре. Опция -i заставляет mv спрашивать подтверждение, если команда собирается перезаписать существующий файл.</p>

		<p><i>Фил Хьюз (Phil Hughes)</i></p>

		<h2>Примечание переводчика</h2>
	       
		<p>Нашёл ещё один вариант скрипта для этой задачи:</p>

		<pre class="console">$ find ./ -type f | awk '{ print $1 " " tolower($1) }' | xargs -L 1 mv</pre>

		<p><a href="mailto:vladimir@stupin.su?subject=Фил Хьюз. Преобразовать имена файлов к нижнему регистру, 2008">Написать автору перевода</a></p>

		<p><a href="..">&larr;</a></p>
	</body>
</html>
